<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Box2D: World</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">Box2D<span id="projectnumber">&#160;3.0.0</span>
   </div>
   <div id="projectbrief">A 2D physics engine for games</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('group__world.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">World</div></div>
</div><!--header-->
<div class="contents">

<p>These functions allow you to create a simulation world.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structb2_ray_result" id="r_structb2_ray_result"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structb2_ray_result">b2RayResult</a></td></tr>
<tr class="memdesc:structb2_ray_result"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result from b2World_RayCastClosest.  <a href="#structb2_ray_result">More...</a><br /></td></tr>
<tr class="separator:structb2_ray_result"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structb2_world_def" id="r_structb2_world_def"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#structb2_world_def">b2WorldDef</a></td></tr>
<tr class="memdesc:structb2_world_def"><td class="mdescLeft">&#160;</td><td class="mdescRight">World definition used to create a simulation world.  <a href="#structb2_world_def">More...</a><br /></td></tr>
<tr class="separator:structb2_world_def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structb2_debug_draw.html">b2DebugDraw</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct holds callbacks you can implement to draw a Box2D world.  <a href="structb2_debug_draw.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga2e71ae8fa38cb62acdd21b5715630f6e" id="r_ga2e71ae8fa38cb62acdd21b5715630f6e"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2e71ae8fa38cb62acdd21b5715630f6e">b2TaskCallback</a>(int32_t startIndex, int32_t endIndex, uint32_t workerIndex, void *taskContext)</td></tr>
<tr class="memdesc:ga2e71ae8fa38cb62acdd21b5715630f6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task interface This is prototype for a Box2D task.  <br /></td></tr>
<tr class="separator:ga2e71ae8fa38cb62acdd21b5715630f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe25f2bb74325a128203d7c009d81157" id="r_gabe25f2bb74325a128203d7c009d81157"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabe25f2bb74325a128203d7c009d81157">b2EnqueueTaskCallback</a>(<a class="el" href="#ga2e71ae8fa38cb62acdd21b5715630f6e">b2TaskCallback</a> *task, int32_t itemCount, int32_t minRange, void *taskContext, void *userContext)</td></tr>
<tr class="memdesc:gabe25f2bb74325a128203d7c009d81157"><td class="mdescLeft">&#160;</td><td class="mdescRight">These functions can be provided to Box2D to invoke a task system.  <br /></td></tr>
<tr class="separator:gabe25f2bb74325a128203d7c009d81157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6f6e1bb503bb0bd7a7fc1552ef7236a" id="r_gaf6f6e1bb503bb0bd7a7fc1552ef7236a"><td class="memItemLeft" align="right" valign="top"><a id="gaf6f6e1bb503bb0bd7a7fc1552ef7236a" name="gaf6f6e1bb503bb0bd7a7fc1552ef7236a"></a>
typedef void&#160;</td><td class="memItemRight" valign="bottom"><b>b2FinishTaskCallback</b>(void *userTask, void *userContext)</td></tr>
<tr class="memdesc:gaf6f6e1bb503bb0bd7a7fc1552ef7236a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes a user task object that wraps a Box2D task. <br /></td></tr>
<tr class="separator:gaf6f6e1bb503bb0bd7a7fc1552ef7236a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf224d1619b8039789d560ef4e800a7df" id="r_gaf224d1619b8039789d560ef4e800a7df"><td class="memItemLeft" align="right" valign="top">typedef bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf224d1619b8039789d560ef4e800a7df">b2CustomFilterFcn</a>(<a class="el" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeIdA, <a class="el" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeIdB, void *context)</td></tr>
<tr class="memdesc:gaf224d1619b8039789d560ef4e800a7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype for a contact filter callback.  <br /></td></tr>
<tr class="separator:gaf224d1619b8039789d560ef4e800a7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc67e8e35069f7fc50755006ae5b4bab" id="r_gabc67e8e35069f7fc50755006ae5b4bab"><td class="memItemLeft" align="right" valign="top">typedef bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gabc67e8e35069f7fc50755006ae5b4bab">b2PreSolveFcn</a>(<a class="el" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeIdA, <a class="el" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeIdB, <a class="el" href="group__collision.html#structb2_manifold">b2Manifold</a> *manifold, void *context)</td></tr>
<tr class="memdesc:gabc67e8e35069f7fc50755006ae5b4bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype for a pre-solve callback.  <br /></td></tr>
<tr class="separator:gabc67e8e35069f7fc50755006ae5b4bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d93e3d04057bd9673689e7e27f6a7d3" id="r_ga1d93e3d04057bd9673689e7e27f6a7d3"><td class="memItemLeft" align="right" valign="top">typedef bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga1d93e3d04057bd9673689e7e27f6a7d3">b2OverlapResultFcn</a>(<a class="el" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeId, void *context)</td></tr>
<tr class="memdesc:ga1d93e3d04057bd9673689e7e27f6a7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype callback for overlap queries.  <br /></td></tr>
<tr class="separator:ga1d93e3d04057bd9673689e7e27f6a7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad34f863cfebe93a7d6448c30e30f6a01" id="r_gad34f863cfebe93a7d6448c30e30f6a01"><td class="memItemLeft" align="right" valign="top">typedef float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad34f863cfebe93a7d6448c30e30f6a01">b2CastResultFcn</a>(<a class="el" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeId, <a class="el" href="group__math.html#structb2_vec2">b2Vec2</a> point, <a class="el" href="group__math.html#structb2_vec2">b2Vec2</a> normal, float fraction, void *context)</td></tr>
<tr class="memdesc:gad34f863cfebe93a7d6448c30e30f6a01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype callback for ray casts.  <br /></td></tr>
<tr class="separator:gad34f863cfebe93a7d6448c30e30f6a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga47d081b90cf21396822f148e06598af0" id="r_ga47d081b90cf21396822f148e06598af0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__id.html#structb2_world_id">b2WorldId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga47d081b90cf21396822f148e06598af0">b2CreateWorld</a> (const <a class="el" href="#structb2_world_def">b2WorldDef</a> *def)</td></tr>
<tr class="memdesc:ga47d081b90cf21396822f148e06598af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a world for rigid body simulation.  <br /></td></tr>
<tr class="separator:ga47d081b90cf21396822f148e06598af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab03e6659955d615e0b935aeba7a3cc74" id="r_gab03e6659955d615e0b935aeba7a3cc74"><td class="memItemLeft" align="right" valign="top"><a id="gab03e6659955d615e0b935aeba7a3cc74" name="gab03e6659955d615e0b935aeba7a3cc74"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>b2DestroyWorld</b> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId)</td></tr>
<tr class="memdesc:gab03e6659955d615e0b935aeba7a3cc74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a world. <br /></td></tr>
<tr class="separator:gab03e6659955d615e0b935aeba7a3cc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e1eac385787b7712b9322594dcbd768" id="r_ga7e1eac385787b7712b9322594dcbd768"><td class="memItemLeft" align="right" valign="top"><a id="ga7e1eac385787b7712b9322594dcbd768" name="ga7e1eac385787b7712b9322594dcbd768"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>b2World_IsValid</b> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> id)</td></tr>
<tr class="memdesc:ga7e1eac385787b7712b9322594dcbd768"><td class="mdescLeft">&#160;</td><td class="mdescRight">World id validation. Provides validation for up to 64K allocations. <br /></td></tr>
<tr class="separator:ga7e1eac385787b7712b9322594dcbd768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0249cf75273319ca548d55734d7297c4" id="r_ga0249cf75273319ca548d55734d7297c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0249cf75273319ca548d55734d7297c4">b2World_Step</a> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId, float timeStep, int subStepCount)</td></tr>
<tr class="memdesc:ga0249cf75273319ca548d55734d7297c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulate a world for one time step.  <br /></td></tr>
<tr class="separator:ga0249cf75273319ca548d55734d7297c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03d36d2c477ae302e7181d59244a1bb9" id="r_ga03d36d2c477ae302e7181d59244a1bb9"><td class="memItemLeft" align="right" valign="top"><a id="ga03d36d2c477ae302e7181d59244a1bb9" name="ga03d36d2c477ae302e7181d59244a1bb9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>b2World_Draw</b> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId, <a class="el" href="structb2_debug_draw.html">b2DebugDraw</a> *draw)</td></tr>
<tr class="memdesc:ga03d36d2c477ae302e7181d59244a1bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this to draw shapes and other debug draw data. <br /></td></tr>
<tr class="separator:ga03d36d2c477ae302e7181d59244a1bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaee4035fe8a3c8531850827c2ce7ec1" id="r_gadaee4035fe8a3c8531850827c2ce7ec1"><td class="memItemLeft" align="right" valign="top"><a id="gadaee4035fe8a3c8531850827c2ce7ec1" name="gadaee4035fe8a3c8531850827c2ce7ec1"></a>
<a class="el" href="group__events.html#structb2_body_events">b2BodyEvents</a>&#160;</td><td class="memItemRight" valign="bottom"><b>b2World_GetBodyEvents</b> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId)</td></tr>
<tr class="memdesc:gadaee4035fe8a3c8531850827c2ce7ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the body events for the current time step. The event data is transient. Do not store a reference to this data. <br /></td></tr>
<tr class="separator:gadaee4035fe8a3c8531850827c2ce7ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga990f8c08b8606146e74de326577472b1" id="r_ga990f8c08b8606146e74de326577472b1"><td class="memItemLeft" align="right" valign="top"><a id="ga990f8c08b8606146e74de326577472b1" name="ga990f8c08b8606146e74de326577472b1"></a>
<a class="el" href="group__events.html#structb2_sensor_events">b2SensorEvents</a>&#160;</td><td class="memItemRight" valign="bottom"><b>b2World_GetSensorEvents</b> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId)</td></tr>
<tr class="memdesc:ga990f8c08b8606146e74de326577472b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get sensor events for the current time step. The event data is transient. Do not store a reference to this data. <br /></td></tr>
<tr class="separator:ga990f8c08b8606146e74de326577472b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67e9e2ecf3897d4c7254196395be65ca" id="r_ga67e9e2ecf3897d4c7254196395be65ca"><td class="memItemLeft" align="right" valign="top"><a id="ga67e9e2ecf3897d4c7254196395be65ca" name="ga67e9e2ecf3897d4c7254196395be65ca"></a>
<a class="el" href="group__events.html#structb2_contact_events">b2ContactEvents</a>&#160;</td><td class="memItemRight" valign="bottom"><b>b2World_GetContactEvents</b> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId)</td></tr>
<tr class="memdesc:ga67e9e2ecf3897d4c7254196395be65ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get contact events for this current time step. The event data is transient. Do not store a reference to this data. <br /></td></tr>
<tr class="separator:ga67e9e2ecf3897d4c7254196395be65ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabec8eeee96726f5d0f950228daeb602f" id="r_gabec8eeee96726f5d0f950228daeb602f"><td class="memItemLeft" align="right" valign="top"><a id="gabec8eeee96726f5d0f950228daeb602f" name="gabec8eeee96726f5d0f950228daeb602f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>b2World_OverlapAABB</b> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId, <a class="el" href="group__math.html#structb2_a_a_b_b">b2AABB</a> aabb, <a class="el" href="group__shape.html#structb2_query_filter">b2QueryFilter</a> filter, <a class="el" href="#ga1d93e3d04057bd9673689e7e27f6a7d3">b2OverlapResultFcn</a> *fcn, void *context)</td></tr>
<tr class="memdesc:gabec8eeee96726f5d0f950228daeb602f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overlap test for all shapes that <em>potentially</em> overlap the provided AABB. <br /></td></tr>
<tr class="separator:gabec8eeee96726f5d0f950228daeb602f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66c22a9441b360eb65ddce78b8861370" id="r_ga66c22a9441b360eb65ddce78b8861370"><td class="memItemLeft" align="right" valign="top"><a id="ga66c22a9441b360eb65ddce78b8861370" name="ga66c22a9441b360eb65ddce78b8861370"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>b2World_OverlapCircle</b> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId, const <a class="el" href="group__geometry.html#structb2_circle">b2Circle</a> *circle, <a class="el" href="group__math.html#structb2_transform">b2Transform</a> transform, <a class="el" href="group__shape.html#structb2_query_filter">b2QueryFilter</a> filter, <a class="el" href="#ga1d93e3d04057bd9673689e7e27f6a7d3">b2OverlapResultFcn</a> *fcn, void *context)</td></tr>
<tr class="memdesc:ga66c22a9441b360eb65ddce78b8861370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overlap test for for all shapes that overlap the provided circle. <br /></td></tr>
<tr class="separator:ga66c22a9441b360eb65ddce78b8861370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga591f29e8c1ea08a2b95990d623cd459a" id="r_ga591f29e8c1ea08a2b95990d623cd459a"><td class="memItemLeft" align="right" valign="top"><a id="ga591f29e8c1ea08a2b95990d623cd459a" name="ga591f29e8c1ea08a2b95990d623cd459a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>b2World_OverlapCapsule</b> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId, const <a class="el" href="group__geometry.html#structb2_capsule">b2Capsule</a> *capsule, <a class="el" href="group__math.html#structb2_transform">b2Transform</a> transform, <a class="el" href="group__shape.html#structb2_query_filter">b2QueryFilter</a> filter, <a class="el" href="#ga1d93e3d04057bd9673689e7e27f6a7d3">b2OverlapResultFcn</a> *fcn, void *context)</td></tr>
<tr class="memdesc:ga591f29e8c1ea08a2b95990d623cd459a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overlap test for all shapes that overlap the provided capsule. <br /></td></tr>
<tr class="separator:ga591f29e8c1ea08a2b95990d623cd459a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae33469ffd3b9867706c222cc0223567c" id="r_gae33469ffd3b9867706c222cc0223567c"><td class="memItemLeft" align="right" valign="top"><a id="gae33469ffd3b9867706c222cc0223567c" name="gae33469ffd3b9867706c222cc0223567c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>b2World_OverlapPolygon</b> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId, const <a class="el" href="group__geometry.html#structb2_polygon">b2Polygon</a> *polygon, <a class="el" href="group__math.html#structb2_transform">b2Transform</a> transform, <a class="el" href="group__shape.html#structb2_query_filter">b2QueryFilter</a> filter, <a class="el" href="#ga1d93e3d04057bd9673689e7e27f6a7d3">b2OverlapResultFcn</a> *fcn, void *context)</td></tr>
<tr class="memdesc:gae33469ffd3b9867706c222cc0223567c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overlap test for all shapes that overlap the provided polygon. <br /></td></tr>
<tr class="separator:gae33469ffd3b9867706c222cc0223567c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac41944f34d33af325db84369e119fdbb" id="r_gac41944f34d33af325db84369e119fdbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gac41944f34d33af325db84369e119fdbb">b2World_CastRay</a> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId, <a class="el" href="group__math.html#structb2_vec2">b2Vec2</a> origin, <a class="el" href="group__math.html#structb2_vec2">b2Vec2</a> translation, <a class="el" href="group__shape.html#structb2_query_filter">b2QueryFilter</a> filter, <a class="el" href="#gad34f863cfebe93a7d6448c30e30f6a01">b2CastResultFcn</a> *fcn, void *context)</td></tr>
<tr class="memdesc:gac41944f34d33af325db84369e119fdbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a ray into the world to collect shapes in the path of the ray.  <br /></td></tr>
<tr class="separator:gac41944f34d33af325db84369e119fdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10751c89082cc1d63a7ed90b3ef9bb0a" id="r_ga10751c89082cc1d63a7ed90b3ef9bb0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#structb2_ray_result">b2RayResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga10751c89082cc1d63a7ed90b3ef9bb0a">b2World_CastRayClosest</a> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId, <a class="el" href="group__math.html#structb2_vec2">b2Vec2</a> origin, <a class="el" href="group__math.html#structb2_vec2">b2Vec2</a> translation, <a class="el" href="group__shape.html#structb2_query_filter">b2QueryFilter</a> filter)</td></tr>
<tr class="memdesc:ga10751c89082cc1d63a7ed90b3ef9bb0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a ray into the world to collect the closest hit.  <br /></td></tr>
<tr class="separator:ga10751c89082cc1d63a7ed90b3ef9bb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27c9be84644d07c78daa9a7670704a34" id="r_ga27c9be84644d07c78daa9a7670704a34"><td class="memItemLeft" align="right" valign="top"><a id="ga27c9be84644d07c78daa9a7670704a34" name="ga27c9be84644d07c78daa9a7670704a34"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>b2World_CastCircle</b> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId, const <a class="el" href="group__geometry.html#structb2_circle">b2Circle</a> *circle, <a class="el" href="group__math.html#structb2_transform">b2Transform</a> originTransform, <a class="el" href="group__math.html#structb2_vec2">b2Vec2</a> translation, <a class="el" href="group__shape.html#structb2_query_filter">b2QueryFilter</a> filter, <a class="el" href="#gad34f863cfebe93a7d6448c30e30f6a01">b2CastResultFcn</a> *fcn, void *context)</td></tr>
<tr class="memdesc:ga27c9be84644d07c78daa9a7670704a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a circle through the world. Similar to a cast ray except that a circle is cast instead of a point. <br /></td></tr>
<tr class="separator:ga27c9be84644d07c78daa9a7670704a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13456f3533af4369fc923ca751a5ca40" id="r_ga13456f3533af4369fc923ca751a5ca40"><td class="memItemLeft" align="right" valign="top"><a id="ga13456f3533af4369fc923ca751a5ca40" name="ga13456f3533af4369fc923ca751a5ca40"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>b2World_CastCapsule</b> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId, const <a class="el" href="group__geometry.html#structb2_capsule">b2Capsule</a> *capsule, <a class="el" href="group__math.html#structb2_transform">b2Transform</a> originTransform, <a class="el" href="group__math.html#structb2_vec2">b2Vec2</a> translation, <a class="el" href="group__shape.html#structb2_query_filter">b2QueryFilter</a> filter, <a class="el" href="#gad34f863cfebe93a7d6448c30e30f6a01">b2CastResultFcn</a> *fcn, void *context)</td></tr>
<tr class="memdesc:ga13456f3533af4369fc923ca751a5ca40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a capsule through the world. Similar to a cast ray except that a capsule is cast instead of a point. <br /></td></tr>
<tr class="separator:ga13456f3533af4369fc923ca751a5ca40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1700b359b34064663623f612dfb4261f" id="r_ga1700b359b34064663623f612dfb4261f"><td class="memItemLeft" align="right" valign="top"><a id="ga1700b359b34064663623f612dfb4261f" name="ga1700b359b34064663623f612dfb4261f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>b2World_CastPolygon</b> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId, const <a class="el" href="group__geometry.html#structb2_polygon">b2Polygon</a> *polygon, <a class="el" href="group__math.html#structb2_transform">b2Transform</a> originTransform, <a class="el" href="group__math.html#structb2_vec2">b2Vec2</a> translation, <a class="el" href="group__shape.html#structb2_query_filter">b2QueryFilter</a> filter, <a class="el" href="#gad34f863cfebe93a7d6448c30e30f6a01">b2CastResultFcn</a> *fcn, void *context)</td></tr>
<tr class="memdesc:ga1700b359b34064663623f612dfb4261f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a polygon through the world. Similar to a cast ray except that a polygon is cast instead of a point. <br /></td></tr>
<tr class="separator:ga1700b359b34064663623f612dfb4261f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d2480e1321163a63c8d63103c746b45" id="r_ga2d2480e1321163a63c8d63103c746b45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2d2480e1321163a63c8d63103c746b45">b2World_EnableSleeping</a> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId, bool flag)</td></tr>
<tr class="memdesc:ga2d2480e1321163a63c8d63103c746b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable sleep.  <br /></td></tr>
<tr class="separator:ga2d2480e1321163a63c8d63103c746b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b21f29097e46256706875a189e3c506" id="r_ga3b21f29097e46256706875a189e3c506"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga3b21f29097e46256706875a189e3c506">b2World_EnableContinuous</a> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId, bool flag)</td></tr>
<tr class="memdesc:ga3b21f29097e46256706875a189e3c506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable continuous collision between dynamic and static bodies.  <br /></td></tr>
<tr class="separator:ga3b21f29097e46256706875a189e3c506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfca0c8675db1e5b0e59b4ce43ef737c" id="r_gacfca0c8675db1e5b0e59b4ce43ef737c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gacfca0c8675db1e5b0e59b4ce43ef737c">b2World_SetRestitutionThreshold</a> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId, float value)</td></tr>
<tr class="memdesc:gacfca0c8675db1e5b0e59b4ce43ef737c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the restitution threshold.  <br /></td></tr>
<tr class="separator:gacfca0c8675db1e5b0e59b4ce43ef737c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab493024d7a53ed74dcdd7c0768ff1449" id="r_gab493024d7a53ed74dcdd7c0768ff1449"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab493024d7a53ed74dcdd7c0768ff1449">b2World_SetHitEventThreshold</a> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId, float value)</td></tr>
<tr class="memdesc:gab493024d7a53ed74dcdd7c0768ff1449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the hit event threshold.  <br /></td></tr>
<tr class="separator:gab493024d7a53ed74dcdd7c0768ff1449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga867aff6aa6be0203a46fe9b33db8a99c" id="r_ga867aff6aa6be0203a46fe9b33db8a99c"><td class="memItemLeft" align="right" valign="top"><a id="ga867aff6aa6be0203a46fe9b33db8a99c" name="ga867aff6aa6be0203a46fe9b33db8a99c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>b2World_SetCustomFilterCallback</b> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId, <a class="el" href="#gaf224d1619b8039789d560ef4e800a7df">b2CustomFilterFcn</a> *fcn, void *context)</td></tr>
<tr class="memdesc:ga867aff6aa6be0203a46fe9b33db8a99c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the custom filter callback. This is optional. <br /></td></tr>
<tr class="separator:ga867aff6aa6be0203a46fe9b33db8a99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2b671d813fe2a0324d2b6c78f6816fc" id="r_gae2b671d813fe2a0324d2b6c78f6816fc"><td class="memItemLeft" align="right" valign="top"><a id="gae2b671d813fe2a0324d2b6c78f6816fc" name="gae2b671d813fe2a0324d2b6c78f6816fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>b2World_SetPreSolveCallback</b> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId, <a class="el" href="#gabc67e8e35069f7fc50755006ae5b4bab">b2PreSolveFcn</a> *fcn, void *context)</td></tr>
<tr class="memdesc:gae2b671d813fe2a0324d2b6c78f6816fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the pre-solve callback. This is optional. <br /></td></tr>
<tr class="separator:gae2b671d813fe2a0324d2b6c78f6816fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79b58bd882494c92d0d6ce7d5d42bd21" id="r_ga79b58bd882494c92d0d6ce7d5d42bd21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga79b58bd882494c92d0d6ce7d5d42bd21">b2World_SetGravity</a> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId, <a class="el" href="group__math.html#structb2_vec2">b2Vec2</a> gravity)</td></tr>
<tr class="memdesc:ga79b58bd882494c92d0d6ce7d5d42bd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the gravity vector for the entire world.  <br /></td></tr>
<tr class="separator:ga79b58bd882494c92d0d6ce7d5d42bd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee5f05e578755e05759dd986d804d7b8" id="r_gaee5f05e578755e05759dd986d804d7b8"><td class="memItemLeft" align="right" valign="top"><a id="gaee5f05e578755e05759dd986d804d7b8" name="gaee5f05e578755e05759dd986d804d7b8"></a>
<a class="el" href="group__math.html#structb2_vec2">b2Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><b>b2World_GetGravity</b> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId)</td></tr>
<tr class="memdesc:gaee5f05e578755e05759dd986d804d7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the gravity vector. <br /></td></tr>
<tr class="separator:gaee5f05e578755e05759dd986d804d7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4f74b0e0d4bb215caa893f0b273c209" id="r_gab4f74b0e0d4bb215caa893f0b273c209"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab4f74b0e0d4bb215caa893f0b273c209">b2World_Explode</a> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId, <a class="el" href="group__math.html#structb2_vec2">b2Vec2</a> position, float radius, float impulse)</td></tr>
<tr class="memdesc:gab4f74b0e0d4bb215caa893f0b273c209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a radial explosion.  <br /></td></tr>
<tr class="separator:gab4f74b0e0d4bb215caa893f0b273c209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga059c7d72a77c323c1356bcf04d4a5f3f" id="r_ga059c7d72a77c323c1356bcf04d4a5f3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga059c7d72a77c323c1356bcf04d4a5f3f">b2World_SetContactTuning</a> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId, float hertz, float dampingRatio, float pushVelocity)</td></tr>
<tr class="memdesc:ga059c7d72a77c323c1356bcf04d4a5f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust contact tuning parameters.  <br /></td></tr>
<tr class="separator:ga059c7d72a77c323c1356bcf04d4a5f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga713e836ba76b62a35911359eca9a1539" id="r_ga713e836ba76b62a35911359eca9a1539"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga713e836ba76b62a35911359eca9a1539">b2World_EnableWarmStarting</a> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId, bool flag)</td></tr>
<tr class="memdesc:ga713e836ba76b62a35911359eca9a1539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable constraint warm starting.  <br /></td></tr>
<tr class="separator:ga713e836ba76b62a35911359eca9a1539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bd843ba8e6af02791d73d9e7c717930" id="r_ga4bd843ba8e6af02791d73d9e7c717930"><td class="memItemLeft" align="right" valign="top"><a id="ga4bd843ba8e6af02791d73d9e7c717930" name="ga4bd843ba8e6af02791d73d9e7c717930"></a>
b2Profile&#160;</td><td class="memItemRight" valign="bottom"><b>b2World_GetProfile</b> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId)</td></tr>
<tr class="memdesc:ga4bd843ba8e6af02791d73d9e7c717930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current world performance profile. <br /></td></tr>
<tr class="separator:ga4bd843ba8e6af02791d73d9e7c717930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad81a551a0f152edf995b70fca5686795" id="r_gad81a551a0f152edf995b70fca5686795"><td class="memItemLeft" align="right" valign="top"><a id="gad81a551a0f152edf995b70fca5686795" name="gad81a551a0f152edf995b70fca5686795"></a>
b2Counters&#160;</td><td class="memItemRight" valign="bottom"><b>b2World_GetCounters</b> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId)</td></tr>
<tr class="memdesc:gad81a551a0f152edf995b70fca5686795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get world counters and sizes. <br /></td></tr>
<tr class="separator:gad81a551a0f152edf995b70fca5686795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3295ddbb3a025e5ce35d374b1ab4d9b6" id="r_ga3295ddbb3a025e5ce35d374b1ab4d9b6"><td class="memItemLeft" align="right" valign="top"><a id="ga3295ddbb3a025e5ce35d374b1ab4d9b6" name="ga3295ddbb3a025e5ce35d374b1ab4d9b6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>b2World_DumpMemoryStats</b> (<a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> worldId)</td></tr>
<tr class="memdesc:ga3295ddbb3a025e5ce35d374b1ab4d9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump memory stats to box2d_memory.txt. <br /></td></tr>
<tr class="separator:ga3295ddbb3a025e5ce35d374b1ab4d9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2777d7b8c7f2f289d5b70b3da9bd75f" id="r_gaf2777d7b8c7f2f289d5b70b3da9bd75f"><td class="memItemLeft" align="right" valign="top"><a id="gaf2777d7b8c7f2f289d5b70b3da9bd75f" name="gaf2777d7b8c7f2f289d5b70b3da9bd75f"></a>
<a class="el" href="#structb2_world_def">b2WorldDef</a>&#160;</td><td class="memItemRight" valign="bottom"><b>b2DefaultWorldDef</b> (void)</td></tr>
<tr class="memdesc:gaf2777d7b8c7f2f289d5b70b3da9bd75f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this to initialize your world definition. <br /></td></tr>
<tr class="separator:gaf2777d7b8c7f2f289d5b70b3da9bd75f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>These functions allow you to create a simulation world. </p>
<p>You can add rigid bodies and joint constraints to the world and run the simulation. You can get contact information to get contact points and normals as well as events. You can query to world, checking for overlaps and casting rays or shapes. There is also debugging information such as debug draw, timing information, and counters. You can find documentation here: <a href="https://box2d.org/">https://box2d.org/</a> </p>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structb2_ray_result" id="structb2_ray_result"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structb2_ray_result">&#9670;&#160;</a></span>b2RayResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct b2RayResult</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Result from b2World_RayCastClosest. </p>
</div><div class="dynheader">
Collaboration diagram for b2RayResult:</div>
<div class="dyncontent">
<div class="center"><img src="structb2_ray_result__coll__graph.png" border="0" usemap="#ab2_ray_result_coll__map" alt="Collaboration graph"/></div>
<map name="ab2_ray_result_coll__map" id="ab2_ray_result_coll__map">
<area shape="rect" title="Result from b2World_RayCastClosest." alt="" coords="48,108,144,133"/>
<area shape="rect" href="group__id.html#structb2_shape_id" title="Shape id references a shape instance. This should be treated as an opaque handle." alt="" coords="5,5,88,31"/>
<area shape="poly" title=" " alt="" coords="55,45,69,83,87,106,82,109,64,85,50,47"/>
<area shape="rect" href="group__math.html#structb2_vec2" title="2D vector This can be used to represent a point or free vector" alt="" coords="112,5,179,31"/>
<area shape="poly" title=" " alt="" coords="137,46,118,85,105,109,101,106,114,83,132,44"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a4cc7f0682e98e7913f6c75c7b642cba3" name="a4cc7f0682e98e7913f6c75c7b642cba3"></a>float</td>
<td class="fieldname">
fraction</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="adc4afe94c61933845189ceeeb89c9b9c" name="adc4afe94c61933845189ceeeb89c9b9c"></a>bool</td>
<td class="fieldname">
hit</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a7190e02fbc56a9ef833701282718e287" name="a7190e02fbc56a9ef833701282718e287"></a><a class="el" href="group__math.html#structb2_vec2">b2Vec2</a></td>
<td class="fieldname">
normal</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aefb7066b3ae844322effa49e39246495" name="aefb7066b3ae844322effa49e39246495"></a><a class="el" href="group__math.html#structb2_vec2">b2Vec2</a></td>
<td class="fieldname">
point</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="afce3c934c21a8986fae0f6407630d907" name="afce3c934c21a8986fae0f6407630d907"></a><a class="el" href="group__id.html#structb2_shape_id">b2ShapeId</a></td>
<td class="fieldname">
shapeId</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structb2_world_def" id="structb2_world_def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structb2_world_def">&#9670;&#160;</a></span>b2WorldDef</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct b2WorldDef</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>World definition used to create a simulation world. </p>
<p>Must be initialized using <a class="el" href="#gaf2777d7b8c7f2f289d5b70b3da9bd75f" title="Use this to initialize your world definition.">b2DefaultWorldDef()</a>. </p>
</div><div class="dynheader">
Collaboration diagram for b2WorldDef:</div>
<div class="dyncontent">
<div class="center"><img src="structb2_world_def__coll__graph.png" border="0" usemap="#ab2_world_def_coll__map" alt="Collaboration graph"/></div>
<map name="ab2_world_def_coll__map" id="ab2_world_def_coll__map">
<area shape="rect" title="World definition used to create a simulation world." alt="" coords="5,93,95,119"/>
<area shape="rect" href="group__math.html#structb2_vec2" title="2D vector This can be used to represent a point or free vector" alt="" coords="17,5,83,31"/>
<area shape="poly" title=" " alt="" coords="53,46,53,93,47,93,47,46"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a6b688e8acd9a4150a21d695b71a6e932" name="a6b688e8acd9a4150a21d695b71a6e932"></a>float</td>
<td class="fieldname">
contactDampingRatio</td>
<td class="fielddoc">
Contact bounciness. Non-dimensional. </td></tr>
<tr><td class="fieldtype">
<a id="a5f2d7d174fdd44f9e8f1717c47b62fd8" name="a5f2d7d174fdd44f9e8f1717c47b62fd8"></a>float</td>
<td class="fieldname">
contactHertz</td>
<td class="fielddoc">
Contact stiffness. Cycles per second. </td></tr>
<tr><td class="fieldtype">
<a id="ace7817103600c8590338445222e2711d" name="ace7817103600c8590338445222e2711d"></a>float</td>
<td class="fieldname">
contactPushoutVelocity</td>
<td class="fielddoc">
This parameter controls how fast overlap is resolved and has units of meters per second. </td></tr>
<tr><td class="fieldtype">
<a id="a7c83fe7f22bedaf2f4ffee4cdb48df0f" name="a7c83fe7f22bedaf2f4ffee4cdb48df0f"></a>bool</td>
<td class="fieldname">
enableContinous</td>
<td class="fielddoc">
Enable continuous collision. </td></tr>
<tr><td class="fieldtype">
<a id="a97dfa093c69aa2182be074e90b3c9edf" name="a97dfa093c69aa2182be074e90b3c9edf"></a>bool</td>
<td class="fieldname">
enableSleep</td>
<td class="fielddoc">
Can bodies go to sleep to improve performance. </td></tr>
<tr><td class="fieldtype">
<a id="aee2d25f33f224008eae4825353757137" name="aee2d25f33f224008eae4825353757137"></a><a class="el" href="#gabe25f2bb74325a128203d7c009d81157">b2EnqueueTaskCallback</a> *</td>
<td class="fieldname">
enqueueTask</td>
<td class="fielddoc">
Function to spawn tasks. </td></tr>
<tr><td class="fieldtype">
<a id="a7f1b41bc118d3d34d9d76f09523129d1" name="a7f1b41bc118d3d34d9d76f09523129d1"></a><a class="el" href="#gaf6f6e1bb503bb0bd7a7fc1552ef7236a">b2FinishTaskCallback</a> *</td>
<td class="fieldname">
finishTask</td>
<td class="fielddoc">
Function to finish a task. </td></tr>
<tr><td class="fieldtype">
<a id="a9152b6fd416622e7f00ba0bac86508dd" name="a9152b6fd416622e7f00ba0bac86508dd"></a><a class="el" href="group__math.html#structb2_vec2">b2Vec2</a></td>
<td class="fieldname">
gravity</td>
<td class="fielddoc">
Gravity vector. Box2D has no up-vector defined. </td></tr>
<tr><td class="fieldtype">
<a id="a8fad064bf7a90119a4e4690b137afc4f" name="a8fad064bf7a90119a4e4690b137afc4f"></a>float</td>
<td class="fieldname">
hitEventThreshold</td>
<td class="fielddoc">
Threshold velocity for hit events. Usually meters per second. </td></tr>
<tr><td class="fieldtype">
<a id="adab21e2fc97bcf90315d58b5aa64e0ad" name="adab21e2fc97bcf90315d58b5aa64e0ad"></a>int32_t</td>
<td class="fieldname">
internalValue</td>
<td class="fielddoc">
Used internally to detect a valid definition. DO NOT SET. </td></tr>
<tr><td class="fieldtype">
<a id="af440736e44f50902fa7eebea3815727e" name="af440736e44f50902fa7eebea3815727e"></a>float</td>
<td class="fieldname">
jointDampingRatio</td>
<td class="fielddoc">
Joint bounciness. Non-dimensional. </td></tr>
<tr><td class="fieldtype">
<a id="ad90e4c2786b8bf9073f99563e1508f06" name="ad90e4c2786b8bf9073f99563e1508f06"></a>float</td>
<td class="fieldname">
jointHertz</td>
<td class="fielddoc">
Joint stiffness. Cycles per second. </td></tr>
<tr><td class="fieldtype">
<a id="af2bb95e476c0e269141789d22cbaf58d" name="af2bb95e476c0e269141789d22cbaf58d"></a>float</td>
<td class="fieldname">
maximumLinearVelocity</td>
<td class="fielddoc">
Maximum linear velocity. Usually meters per second. </td></tr>
<tr><td class="fieldtype">
<a id="aac6834c8e6e29c0aba4ecaff28cf8195" name="aac6834c8e6e29c0aba4ecaff28cf8195"></a>float</td>
<td class="fieldname">
restitutionThreshold</td>
<td class="fielddoc">
Restitution velocity threshold, usually in m/s. <p>Collisions above this speed have restitution applied (will bounce). </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a8b6f5f54ec26389f31cfbcfd681783f2" name="a8b6f5f54ec26389f31cfbcfd681783f2"></a>void *</td>
<td class="fieldname">
userTaskContext</td>
<td class="fielddoc">
User context that is provided to enqueueTask and finishTask. </td></tr>
<tr><td class="fieldtype">
<a id="ac909817764b448495d5178da27342709" name="ac909817764b448495d5178da27342709"></a>int32_t</td>
<td class="fieldname">
workerCount</td>
<td class="fielddoc">
Number of workers to use with the provided task system. <p>Box2D performs best when using only performance cores and accessing a single L2 cache. Efficiency cores and hyper-threading provide little benefit and may even harm performance. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gad34f863cfebe93a7d6448c30e30f6a01" name="gad34f863cfebe93a7d6448c30e30f6a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad34f863cfebe93a7d6448c30e30f6a01">&#9670;&#160;</a></span>b2CastResultFcn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef float b2CastResultFcn(<a class="el" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeId, <a class="el" href="group__math.html#structb2_vec2">b2Vec2</a> point, <a class="el" href="group__math.html#structb2_vec2">b2Vec2</a> normal, float fraction, void *context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prototype callback for ray casts. </p>
<p>Called for each shape found in the query. You control how the ray cast proceeds by returning a float: return -1: ignore this shape and continue return 0: terminate the ray cast return fraction: clip the ray to this point return 1: don't clip the ray and continue </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shapeId</td><td>the shape hit by the ray </td></tr>
    <tr><td class="paramname">point</td><td>the point of initial intersection </td></tr>
    <tr><td class="paramname">normal</td><td>the normal vector at the point of intersection </td></tr>
    <tr><td class="paramname">fraction</td><td>the fraction along the ray at the point of intersection </td></tr>
    <tr><td class="paramname">context</td><td>the user context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 to filter, 0 to terminate, fraction to clip the ray for closest hit, 1 to continue </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gac41944f34d33af325db84369e119fdbb" title="Cast a ray into the world to collect shapes in the path of the ray.">b2World_CastRay</a> </dd></dl>

</div>
</div>
<a id="gaf224d1619b8039789d560ef4e800a7df" name="gaf224d1619b8039789d560ef4e800a7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf224d1619b8039789d560ef4e800a7df">&#9670;&#160;</a></span>b2CustomFilterFcn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool b2CustomFilterFcn(<a class="el" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeIdA, <a class="el" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeIdB, void *context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prototype for a contact filter callback. </p>
<p>This is called when a contact pair is considered for collision. This allows you to perform custom logic to prevent collision between shapes. This is only called if one of the two shapes has custom filtering enabled. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__shape.html#structb2_shape_def" title="Used to create a shape.">b2ShapeDef</a>. Notes:<ul>
<li>this function must be thread-safe</li>
<li>this is only called if one of the two shapes has enabled custom filtering</li>
<li>this is called only for awake dynamic bodies Return false if you want to disable the <a class="el" href="group__collision.html">Collision</a> </li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Do not attempt to modify the world inside this callback </dd></dl>

</div>
</div>
<a id="gabe25f2bb74325a128203d7c009d81157" name="gabe25f2bb74325a128203d7c009d81157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe25f2bb74325a128203d7c009d81157">&#9670;&#160;</a></span>b2EnqueueTaskCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void * b2EnqueueTaskCallback(<a class="el" href="#ga2e71ae8fa38cb62acdd21b5715630f6e">b2TaskCallback</a> *task, int32_t itemCount, int32_t minRange, void *taskContext, void *userContext)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These functions can be provided to Box2D to invoke a task system. </p>
<p>These are designed to work well with enkiTS. Returns a pointer to the user's task object. May be nullptr. A nullptr indicates to Box2D that the work was executed serially within the callback and there is no need to call b2FinishTaskCallback. The itemCount is the number of Box2D work items that are to be partitioned among workers by the user's task system. This is essentially a parallel-for. The minRange parameter is a suggestion of the minimum number of items to assign per worker to reduce overhead. For example, suppose the task is small and that itemCount is 16. A minRange of 8 suggests that your task system should split the work items among just two workers, even if you have more available. In general the range [startIndex, endIndex) send to b2TaskCallback should obey: endIndex - startIndex &gt;= minRange The exception of course is when itemCount &lt; minRange. </p>

</div>
</div>
<a id="ga1d93e3d04057bd9673689e7e27f6a7d3" name="ga1d93e3d04057bd9673689e7e27f6a7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d93e3d04057bd9673689e7e27f6a7d3">&#9670;&#160;</a></span>b2OverlapResultFcn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool b2OverlapResultFcn(<a class="el" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeId, void *context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prototype callback for overlap queries. </p>
<p>Called for each shape found in the query. </p><dl class="section see"><dt>See also</dt><dd>b2World_QueryAABB </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false to terminate the query. </dd></dl>

</div>
</div>
<a id="gabc67e8e35069f7fc50755006ae5b4bab" name="gabc67e8e35069f7fc50755006ae5b4bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc67e8e35069f7fc50755006ae5b4bab">&#9670;&#160;</a></span>b2PreSolveFcn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool b2PreSolveFcn(<a class="el" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeIdA, <a class="el" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeIdB, <a class="el" href="group__collision.html#structb2_manifold">b2Manifold</a> *manifold, void *context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prototype for a pre-solve callback. </p>
<p>This is called after a contact is updated. This allows you to inspect a contact before it goes to the solver. If you are careful, you can modify the contact manifold (e.g. modify the normal). Notes:</p><ul>
<li>this function must be thread-safe</li>
<li>this is only called if the shape has enabled pre-solve events</li>
<li>this is called only for awake dynamic bodies</li>
<li>this is not called for sensors</li>
<li>the supplied manifold has impulse values from the previous step Return false if you want to disable the contact this step <dl class="section warning"><dt>Warning</dt><dd>Do not attempt to modify the world inside this callback </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ga2e71ae8fa38cb62acdd21b5715630f6e" name="ga2e71ae8fa38cb62acdd21b5715630f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e71ae8fa38cb62acdd21b5715630f6e">&#9670;&#160;</a></span>b2TaskCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void b2TaskCallback(int32_t startIndex, int32_t endIndex, uint32_t workerIndex, void *taskContext)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task interface This is prototype for a Box2D task. </p>
<p>Your task system is expected to invoke the Box2D task with these arguments. The task spans a range of the parallel-for: [startIndex, endIndex) The worker index must correctly identify each worker in the user thread pool, expected in [0, workerCount). A worker must only exist on only one thread at a time and is analogous to the thread index. The task context is the context pointer sent from Box2D when it is enqueued. The startIndex and endIndex are expected in the range [0, itemCount) where itemCount is the argument to b2EnqueueTaskCallback below. Box2D expects startIndex &lt; endIndex and will execute a loop like this:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = startIndex; i &lt; endIndex; ++i)</div>
<div class="line">{</div>
<div class="line">    DoWork();</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga47d081b90cf21396822f148e06598af0" name="ga47d081b90cf21396822f148e06598af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47d081b90cf21396822f148e06598af0">&#9670;&#160;</a></span>b2CreateWorld()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__id.html#structb2_world_id">b2WorldId</a> b2CreateWorld </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#structb2_world_def">b2WorldDef</a> *</td>          <td class="paramname"><span class="paramname"><em>def</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a world for rigid body simulation. </p>
<p>A world contains bodies, shapes, and constraints. You make create up to 128 worlds. Each world is completely independent and may be simulated in parallel. </p><dl class="section return"><dt>Returns</dt><dd>the world id. </dd></dl>

</div>
</div>
<a id="gac41944f34d33af325db84369e119fdbb" name="gac41944f34d33af325db84369e119fdbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac41944f34d33af325db84369e119fdbb">&#9670;&#160;</a></span>b2World_CastRay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void b2World_CastRay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__id.html#structb2_world_id">b2WorldId</a></td>          <td class="paramname"><span class="paramname"><em>worldId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__math.html#structb2_vec2">b2Vec2</a></td>          <td class="paramname"><span class="paramname"><em>origin</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__math.html#structb2_vec2">b2Vec2</a></td>          <td class="paramname"><span class="paramname"><em>translation</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__shape.html#structb2_query_filter">b2QueryFilter</a></td>          <td class="paramname"><span class="paramname"><em>filter</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#gad34f863cfebe93a7d6448c30e30f6a01">b2CastResultFcn</a> *</td>          <td class="paramname"><span class="paramname"><em>fcn</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast a ray into the world to collect shapes in the path of the ray. </p>
<p>Your callback function controls whether you get the closest point, any point, or n-points. The ray-cast ignores shapes that contain the starting point. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worldId</td><td>The world to cast the ray against </td></tr>
    <tr><td class="paramname">origin</td><td>The start point of the ray </td></tr>
    <tr><td class="paramname">translation</td><td>The translation of the ray from the start point to the end point </td></tr>
    <tr><td class="paramname">filter</td><td>Contains bit flags to filter unwanted shapes from the results </td></tr>
    <tr><td class="paramname">fcn</td><td>A user implemented callback function </td></tr>
    <tr><td class="paramname">context</td><td>A user context that is passed along to the callback function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The callback function may receive shapes in any order </dd></dl>

</div>
</div>
<a id="ga10751c89082cc1d63a7ed90b3ef9bb0a" name="ga10751c89082cc1d63a7ed90b3ef9bb0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10751c89082cc1d63a7ed90b3ef9bb0a">&#9670;&#160;</a></span>b2World_CastRayClosest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#structb2_ray_result">b2RayResult</a> b2World_CastRayClosest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__id.html#structb2_world_id">b2WorldId</a></td>          <td class="paramname"><span class="paramname"><em>worldId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__math.html#structb2_vec2">b2Vec2</a></td>          <td class="paramname"><span class="paramname"><em>origin</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__math.html#structb2_vec2">b2Vec2</a></td>          <td class="paramname"><span class="paramname"><em>translation</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__shape.html#structb2_query_filter">b2QueryFilter</a></td>          <td class="paramname"><span class="paramname"><em>filter</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast a ray into the world to collect the closest hit. </p>
<p>This is a convenience function. This is less general than <a class="el" href="#gac41944f34d33af325db84369e119fdbb" title="Cast a ray into the world to collect shapes in the path of the ray.">b2World_CastRay()</a> and does not allow for custom filtering. </p>

</div>
</div>
<a id="ga3b21f29097e46256706875a189e3c506" name="ga3b21f29097e46256706875a189e3c506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b21f29097e46256706875a189e3c506">&#9670;&#160;</a></span>b2World_EnableContinuous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void b2World_EnableContinuous </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__id.html#structb2_world_id">b2WorldId</a></td>          <td class="paramname"><span class="paramname"><em>worldId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable continuous collision between dynamic and static bodies. </p>
<p>Generally you should keep continuous collision enabled to prevent fast moving objects from going through static objects. The performance gain from disabling continuous collision is minor. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#structb2_world_def" title="World definition used to create a simulation world.">b2WorldDef</a> </dd></dl>

</div>
</div>
<a id="ga2d2480e1321163a63c8d63103c746b45" name="ga2d2480e1321163a63c8d63103c746b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d2480e1321163a63c8d63103c746b45">&#9670;&#160;</a></span>b2World_EnableSleeping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void b2World_EnableSleeping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__id.html#structb2_world_id">b2WorldId</a></td>          <td class="paramname"><span class="paramname"><em>worldId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable sleep. </p>
<p>If your application does not need sleeping, you can gain some performance by disabling sleep completely at the world level. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#structb2_world_def" title="World definition used to create a simulation world.">b2WorldDef</a> </dd></dl>

</div>
</div>
<a id="ga713e836ba76b62a35911359eca9a1539" name="ga713e836ba76b62a35911359eca9a1539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga713e836ba76b62a35911359eca9a1539">&#9670;&#160;</a></span>b2World_EnableWarmStarting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void b2World_EnableWarmStarting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__id.html#structb2_world_id">b2WorldId</a></td>          <td class="paramname"><span class="paramname"><em>worldId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flag</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable constraint warm starting. </p>
<p>Advanced feature for testing. Disabling sleeping greatly reduces stability and provides no performance gain. </p>

</div>
</div>
<a id="gab4f74b0e0d4bb215caa893f0b273c209" name="gab4f74b0e0d4bb215caa893f0b273c209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4f74b0e0d4bb215caa893f0b273c209">&#9670;&#160;</a></span>b2World_Explode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void b2World_Explode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__id.html#structb2_world_id">b2WorldId</a></td>          <td class="paramname"><span class="paramname"><em>worldId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__math.html#structb2_vec2">b2Vec2</a></td>          <td class="paramname"><span class="paramname"><em>position</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>radius</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>impulse</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a radial explosion. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worldId</td><td>The world id </td></tr>
    <tr><td class="paramname">position</td><td>The center of the explosion </td></tr>
    <tr><td class="paramname">radius</td><td>The radius of the explosion </td></tr>
    <tr><td class="paramname">impulse</td><td>The impulse of the explosion, typically in kg * m / s or N * s. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga059c7d72a77c323c1356bcf04d4a5f3f" name="ga059c7d72a77c323c1356bcf04d4a5f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga059c7d72a77c323c1356bcf04d4a5f3f">&#9670;&#160;</a></span>b2World_SetContactTuning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void b2World_SetContactTuning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__id.html#structb2_world_id">b2WorldId</a></td>          <td class="paramname"><span class="paramname"><em>worldId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>hertz</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>dampingRatio</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>pushVelocity</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust contact tuning parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worldId</td><td>The world id </td></tr>
    <tr><td class="paramname">hertz</td><td>The contact stiffness (cycles per second) </td></tr>
    <tr><td class="paramname">dampingRatio</td><td>The contact bounciness with 1 being critical damping (non-dimensional) </td></tr>
    <tr><td class="paramname">pushVelocity</td><td>The maximum contact constraint push out velocity (meters per second) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Advanced feature </dd></dl>

</div>
</div>
<a id="ga79b58bd882494c92d0d6ce7d5d42bd21" name="ga79b58bd882494c92d0d6ce7d5d42bd21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79b58bd882494c92d0d6ce7d5d42bd21">&#9670;&#160;</a></span>b2World_SetGravity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void b2World_SetGravity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__id.html#structb2_world_id">b2WorldId</a></td>          <td class="paramname"><span class="paramname"><em>worldId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__math.html#structb2_vec2">b2Vec2</a></td>          <td class="paramname"><span class="paramname"><em>gravity</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the gravity vector for the entire world. </p>
<p>Box2D has no concept of an up direction and this is left as a decision for the application. Typically in m/s^2. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#structb2_world_def" title="World definition used to create a simulation world.">b2WorldDef</a> </dd></dl>

</div>
</div>
<a id="gab493024d7a53ed74dcdd7c0768ff1449" name="gab493024d7a53ed74dcdd7c0768ff1449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab493024d7a53ed74dcdd7c0768ff1449">&#9670;&#160;</a></span>b2World_SetHitEventThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void b2World_SetHitEventThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__id.html#structb2_world_id">b2WorldId</a></td>          <td class="paramname"><span class="paramname"><em>worldId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust the hit event threshold. </p>
<p>This controls the collision velocity needed to generate a <a class="el" href="group__events.html#structb2_contact_hit_event" title="A hit touch event is generated when two shapes collide with a speed faster than the hit speed thresho...">b2ContactHitEvent</a>. Typically in meters per second. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#a8fad064bf7a90119a4e4690b137afc4f" title="Threshold velocity for hit events. Usually meters per second.">b2WorldDef::hitEventThreshold</a> </dd></dl>

</div>
</div>
<a id="gacfca0c8675db1e5b0e59b4ce43ef737c" name="gacfca0c8675db1e5b0e59b4ce43ef737c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfca0c8675db1e5b0e59b4ce43ef737c">&#9670;&#160;</a></span>b2World_SetRestitutionThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void b2World_SetRestitutionThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__id.html#structb2_world_id">b2WorldId</a></td>          <td class="paramname"><span class="paramname"><em>worldId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust the restitution threshold. </p>
<p>It is recommended not to make this value very small because it will prevent bodies from sleeping. Typically in meters per second. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="#structb2_world_def" title="World definition used to create a simulation world.">b2WorldDef</a> </dd></dl>

</div>
</div>
<a id="ga0249cf75273319ca548d55734d7297c4" name="ga0249cf75273319ca548d55734d7297c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0249cf75273319ca548d55734d7297c4">&#9670;&#160;</a></span>b2World_Step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void b2World_Step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__id.html#structb2_world_id">b2WorldId</a></td>          <td class="paramname"><span class="paramname"><em>worldId</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>timeStep</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>subStepCount</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simulate a world for one time step. </p>
<p>This performs collision detection, integration, and constraint solution. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worldId</td><td>The world to simulate </td></tr>
    <tr><td class="paramname">timeStep</td><td>The amount of time to simulate, this should be a fixed number. Typically 1/60. </td></tr>
    <tr><td class="paramname">subStepCount</td><td>The number of sub-steps, increasing the sub-step count can increase accuracy. Typically 4. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
