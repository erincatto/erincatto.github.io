<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Box2D: Simulation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">Box2D<span id="projectnumber">&#160;3.1.0</span>
   </div>
   <div id="projectbrief">A 2D physics engine for games</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_simulation.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Simulation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md48"></a></p>
<p>Rigid body simulation is the primary feature of Box2D. It is the most complex part of Box2D and is the part you will likely interact with the most. Simulation sits on top of the foundation and collision layers, so you should be somewhat familiar with those by now.</p>
<p>Rigid body simulation contains:</p><ul>
<li>worlds</li>
<li>bodies</li>
<li>shapes</li>
<li>contacts</li>
<li>joints</li>
<li>events</li>
</ul>
<p>There are many dependencies between these objects so it is difficult to describe one without referring to another. In the following, you may see some references to objects that have not been described yet. Therefore, you may want to quickly skim this section before reading it closely.</p>
<h1><a class="anchor" id="autotoc_md49"></a>
Ids</h1>
<p>Box2D has a C interface. Typically in a C/C++ library when you create an object with a long lifetime you will keep a pointer (or smart pointer) to the object.</p>
<p>Box2D works differently. Instead of pointers, you are given an <em>id</em> when you create an object. This <em>id</em> acts as a <a href="https://en.wikipedia.org/wiki/Handle_(computing)">handle</a> which helps avoid problems with <a href="https://en.wikipedia.org/wiki/Dangling_pointer">dangling pointers</a>.</p>
<p>This also allows Box2D to use <a href="https://en.wikipedia.org/wiki/Data-oriented_design">data-oriented design</a> internally. This helps to reduce cache misses drastically and also allows for <a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">SIMD</a> optimizations.</p>
<p>So you will be dealing with <code><a class="el" href="group__id.html#structb2_world_id" title="World id references a world instance. This should be treated as an opaque handle.">b2WorldId</a></code>, <code><a class="el" href="group__id.html#structb2_body_id" title="Body id references a body instance. This should be treated as an opaque handle.">b2BodyId</a></code>, etc. These are small opaque structures that you will pass around by value, just like pointers. Box2D creation functions return an id. Functions that operate on Box2D objects take ids.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__id.html#structb2_body_id">b2BodyId</a> myBodyId = <a class="code hl_function" href="group__body.html#ga61874d79bebe9baea67dffef53f840e0">b2CreateBody</a>(myWorldId, &amp;myBodyDef);</div>
<div class="ttc" id="agroup__body_html_ga61874d79bebe9baea67dffef53f840e0"><div class="ttname"><a href="group__body.html#ga61874d79bebe9baea67dffef53f840e0">b2CreateBody</a></div><div class="ttdeci">B2_API b2BodyId b2CreateBody(b2WorldId worldId, const b2BodyDef *def)</div><div class="ttdoc">Create a rigid body given a definition.</div></div>
<div class="ttc" id="agroup__id_html_structb2_body_id"><div class="ttname"><a href="group__id.html#structb2_body_id">b2BodyId</a></div><div class="ttdoc">Body id references a body instance. This should be treated as an opaque handle.</div><div class="ttdef"><b>Definition</b> id.h:45</div></div>
</div><!-- fragment --><p>There are functions to check if an id is valid. Box2D functions will assert if you use an invalid id. This makes debugging easier than using dangling pointers.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__body.html#ga52170501a1db6755a1de288997074c27">b2Body_IsValid</a>(myBodyId) == <span class="keyword">false</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// oops</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__body_html_ga52170501a1db6755a1de288997074c27"><div class="ttname"><a href="group__body.html#ga52170501a1db6755a1de288997074c27">b2Body_IsValid</a></div><div class="ttdeci">B2_API bool b2Body_IsValid(b2BodyId id)</div><div class="ttdoc">Body identifier validation. Can be used to detect orphaned ids. Provides validation for up to 64K all...</div></div>
</div><!-- fragment --><p>Null ids can be established in a couple ways. You can use predefined constants or zero initialization. </p><div class="fragment"><div class="line"><a class="code hl_struct" href="group__id.html#structb2_body_id">b2BodyId</a> myNullBodyId = b2_nullBodyId;</div>
<div class="line"><a class="code hl_struct" href="group__id.html#structb2_body_id">b2BodyId</a> otherNullBodyId = {0};</div>
</div><!-- fragment --><p>You can test if an id is null using some helper macros: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_define" href="group__id.html#ga9e9f041452be21982f129ec4f2b3e259">B2_IS_NULL</a>(myBodyId))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// do something</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__id_html_ga9e9f041452be21982f129ec4f2b3e259"><div class="ttname"><a href="group__id.html#ga9e9f041452be21982f129ec4f2b3e259">B2_IS_NULL</a></div><div class="ttdeci">#define B2_IS_NULL(id)</div><div class="ttdoc">Macro to determine if any id is null.</div><div class="ttdef"><b>Definition</b> id.h:84</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_define" href="group__id.html#ga03e01c7edcf0e9fd00bdfeda812dc715">B2_IS_NON_NULL</a>(myShapeId))</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// do something</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__id_html_ga03e01c7edcf0e9fd00bdfeda812dc715"><div class="ttname"><a href="group__id.html#ga03e01c7edcf0e9fd00bdfeda812dc715">B2_IS_NON_NULL</a></div><div class="ttdeci">#define B2_IS_NON_NULL(id)</div><div class="ttdoc">Macro to determine if any id is non-null.</div><div class="ttdef"><b>Definition</b> id.h:87</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md50"></a>
World</h1>
<p>The Box2D world contains the bodies and joints. It manages all aspects of the simulation and allows for asynchronous queries (like AABB queries and ray-casts). Much of your interactions with Box2D will be with a world object, using <code><a class="el" href="group__id.html#structb2_world_id" title="World id references a world instance. This should be treated as an opaque handle.">b2WorldId</a></code>.</p>
<h2><a class="anchor" id="autotoc_md51"></a>
World Definition</h2>
<p>Worlds are created using a <em>definition</em> structure. This is temporary structure that you can use to configure options for world creation. You <b>must</b> initialize the world definition using <code><a class="el" href="group__world.html#gaf2777d7b8c7f2f289d5b70b3da9bd75f" title="Use this to initialize your world definition.">b2DefaultWorldDef()</a></code>.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__world.html#structb2_world_def">b2WorldDef</a> worldDef = <a class="code hl_function" href="group__world.html#gaf2777d7b8c7f2f289d5b70b3da9bd75f">b2DefaultWorldDef</a>();</div>
<div class="ttc" id="agroup__world_html_gaf2777d7b8c7f2f289d5b70b3da9bd75f"><div class="ttname"><a href="group__world.html#gaf2777d7b8c7f2f289d5b70b3da9bd75f">b2DefaultWorldDef</a></div><div class="ttdeci">b2WorldDef b2DefaultWorldDef(void)</div><div class="ttdoc">Use this to initialize your world definition.</div></div>
<div class="ttc" id="agroup__world_html_structb2_world_def"><div class="ttname"><a href="group__world.html#structb2_world_def">b2WorldDef</a></div><div class="ttdoc">World definition used to create a simulation world.</div><div class="ttdef"><b>Definition</b> types.h:81</div></div>
</div><!-- fragment --><p>The world definition has lots of options, but for most you will use the defaults. You may want to set the gravity:</p>
<div class="fragment"><div class="line">worldDef.<a class="code hl_variable" href="group__world.html#a9152b6fd416622e7f00ba0bac86508dd">gravity</a> = (<a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a>){0.0f, -10.0f};</div>
<div class="ttc" id="agroup__math_html_structb2_vec2"><div class="ttname"><a href="group__math.html#structb2_vec2">b2Vec2</a></div><div class="ttdoc">2D vector This can be used to represent a point or free vector</div><div class="ttdef"><b>Definition</b> math_functions.h:21</div></div>
<div class="ttc" id="agroup__world_html_a9152b6fd416622e7f00ba0bac86508dd"><div class="ttname"><a href="group__world.html#a9152b6fd416622e7f00ba0bac86508dd">b2WorldDef::gravity</a></div><div class="ttdeci">b2Vec2 gravity</div><div class="ttdoc">Gravity vector. Box2D has no up-vector defined.</div><div class="ttdef"><b>Definition</b> types.h:83</div></div>
</div><!-- fragment --><p>If your game doesn't need sleep, you can get a performance boost by completely disabling sleep:</p>
<div class="fragment"><div class="line">worldDef.<a class="code hl_variable" href="group__world.html#a97dfa093c69aa2182be074e90b3c9edf">enableSleep</a> = <span class="keyword">false</span>;</div>
<div class="ttc" id="agroup__world_html_a97dfa093c69aa2182be074e90b3c9edf"><div class="ttname"><a href="group__world.html#a97dfa093c69aa2182be074e90b3c9edf">b2WorldDef::enableSleep</a></div><div class="ttdeci">bool enableSleep</div><div class="ttdoc">Can bodies go to sleep to improve performance.</div><div class="ttdef"><b>Definition</b> types.h:120</div></div>
</div><!-- fragment --><p>You can also configure multithreading to improve performance:</p>
<div class="fragment"><div class="line">worldDef.<a class="code hl_variable" href="group__world.html#aa7ae0e5c67b81b218378cc21a362f288">workerCount</a> = 4;</div>
<div class="line">worldDef.<a class="code hl_variable" href="group__world.html#aee2d25f33f224008eae4825353757137">enqueueTask</a> = myAddTaskFunction;</div>
<div class="line">worldDef.<a class="code hl_variable" href="group__world.html#a7f1b41bc118d3d34d9d76f09523129d1">finishTask</a> = myFinishTaskFunction;</div>
<div class="line">worldDef.<a class="code hl_variable" href="group__world.html#a8b6f5f54ec26389f31cfbcfd681783f2">userTaskContext</a> = &amp;myTaskSystem;</div>
<div class="ttc" id="agroup__world_html_a7f1b41bc118d3d34d9d76f09523129d1"><div class="ttname"><a href="group__world.html#a7f1b41bc118d3d34d9d76f09523129d1">b2WorldDef::finishTask</a></div><div class="ttdeci">b2FinishTaskCallback * finishTask</div><div class="ttdoc">Function to finish a task.</div><div class="ttdef"><b>Definition</b> types.h:138</div></div>
<div class="ttc" id="agroup__world_html_a8b6f5f54ec26389f31cfbcfd681783f2"><div class="ttname"><a href="group__world.html#a8b6f5f54ec26389f31cfbcfd681783f2">b2WorldDef::userTaskContext</a></div><div class="ttdeci">void * userTaskContext</div><div class="ttdoc">User context that is provided to enqueueTask and finishTask.</div><div class="ttdef"><b>Definition</b> types.h:141</div></div>
<div class="ttc" id="agroup__world_html_aa7ae0e5c67b81b218378cc21a362f288"><div class="ttname"><a href="group__world.html#aa7ae0e5c67b81b218378cc21a362f288">b2WorldDef::workerCount</a></div><div class="ttdeci">int workerCount</div><div class="ttdoc">Number of workers to use with the provided task system.</div><div class="ttdef"><b>Definition</b> types.h:132</div></div>
<div class="ttc" id="agroup__world_html_aee2d25f33f224008eae4825353757137"><div class="ttname"><a href="group__world.html#aee2d25f33f224008eae4825353757137">b2WorldDef::enqueueTask</a></div><div class="ttdeci">b2EnqueueTaskCallback * enqueueTask</div><div class="ttdoc">Function to spawn tasks.</div><div class="ttdef"><b>Definition</b> types.h:135</div></div>
</div><!-- fragment --><p>Multithreading is not required but it can improve performance substantially. Read more <a class="el" href="md_foundation.html#multi">here</a>.</p>
<h2><a class="anchor" id="autotoc_md52"></a>
World Lifetime</h2>
<p>Creating a world is done using a world definition.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__id.html#structb2_world_id">b2WorldId</a> myWorldId = <a class="code hl_function" href="group__world.html#gab9ae1534039f2f835c3b9974abbb5110">b2CreateWorld</a>(&amp;worldDef);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... do stuff ...</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__world.html#ga894e7f6f1fca04c2428b69e35f16b46f">b2DestroyWorld</a>(myWorldId);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Nullify id for safety</span></div>
<div class="line">myWorldId = b2_nullWorldId;</div>
<div class="ttc" id="agroup__id_html_structb2_world_id"><div class="ttname"><a href="group__id.html#structb2_world_id">b2WorldId</a></div><div class="ttdoc">World id references a world instance. This should be treated as an opaque handle.</div><div class="ttdef"><b>Definition</b> id.h:38</div></div>
<div class="ttc" id="agroup__world_html_ga894e7f6f1fca04c2428b69e35f16b46f"><div class="ttname"><a href="group__world.html#ga894e7f6f1fca04c2428b69e35f16b46f">b2DestroyWorld</a></div><div class="ttdeci">B2_API void b2DestroyWorld(b2WorldId worldId)</div><div class="ttdoc">Destroy a world.</div></div>
<div class="ttc" id="agroup__world_html_gab9ae1534039f2f835c3b9974abbb5110"><div class="ttname"><a href="group__world.html#gab9ae1534039f2f835c3b9974abbb5110">b2CreateWorld</a></div><div class="ttdeci">B2_API b2WorldId b2CreateWorld(const b2WorldDef *def)</div><div class="ttdoc">Create a world for rigid body simulation.</div></div>
</div><!-- fragment --><p>You can create up to 128 worlds. These worlds do not interact and may be simulated in parallel.</p>
<p>When you destroy a world, every body, shape, and joint is also destroyed. This is much faster than destroying individual objects.</p>
<h2><a class="anchor" id="autotoc_md53"></a>
Simulation</h2>
<p>The world is used to drive the simulation. You specify a time step and a sub-step count. For example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> timeStep = 1.0f / 60.f;</div>
<div class="line">int32_t subSteps = 4;</div>
<div class="line"><a class="code hl_function" href="group__world.html#ga8441b35f0a5d67ccf40961a94d4941ef">b2World_Step</a>(myWorldId, timeStep, subSteps);</div>
<div class="ttc" id="agroup__world_html_ga8441b35f0a5d67ccf40961a94d4941ef"><div class="ttname"><a href="group__world.html#ga8441b35f0a5d67ccf40961a94d4941ef">b2World_Step</a></div><div class="ttdeci">B2_API void b2World_Step(b2WorldId worldId, float timeStep, int subStepCount)</div><div class="ttdoc">Simulate a world for one time step.</div></div>
</div><!-- fragment --><p>After the time step you can examine your bodies and joints for information. Most likely you will grab the position off the bodies so that you can update your game objects and render them. Or more optimally, you will use <code><a class="el" href="group__world.html#ga5e6ffdadb6a72f4435be858a0ac2b8c6" title="Get the body events for the current time step. The event data is transient. Do not store a reference ...">b2World_GetBodyEvents()</a></code>.</p>
<p>You can perform the time step anywhere in your game loop, but you should be aware of the order of things. For example, you must create bodies before the time step if you want to get collision results for the new bodies in that frame.</p>
<p>As I discussed in the <a class="el" href="hello.html">HelloWorld tutorial</a>, you should use a fixed time step. By using a larger time step you can improve performance in low frame rate scenarios. But generally you should use a time steps 1/30 seconds (30Hz) or smaller. A time step of 1/60 seconds (60Hz) will usually deliver a high quality simulation.</p>
<p>The sub-step count is used to increase accuracy. By sub-stepping the solver divides up time into small increments and the bodies move by a small amount. This allows joints and contacts to respond with finer detail. The recommended sub-step count is 4. However, increasing the sub-step count may improve accuracy. For example, long joint chains will stretch less with more sub-steps.</p>
<p>The scissor lift sample shown <a class="el" href="samples.html">here</a> works better with more sub-steps and is configured to use 8 sub-steps. With a primary time step of 1/60 seconds, the scissor lift is taking sub-steps at 480Hz!</p>
<h1><a class="anchor" id="autotoc_md54"></a>
Rigid Bodies</h1>
<p>Rigid bodies, or just <em>bodies</em> have position and velocity. You can apply forces, torques, and impulses to bodies. Bodies can be static, kinematic, or dynamic. Here are the body type definitions:</p>
<h2><a class="anchor" id="autotoc_md55"></a>
Body types</h2>
<p><a class="el" href="group__body.html#gga74ddb02261648c2bff691a866b5c03e0a0608664fbdfecd9d3f33cfdfb904ffbc" title="zero mass, zero velocity, may be manually moved">b2_staticBody</a>: A static body does not move under simulation and behaves as if it has infinite mass. Internally, Box2D stores zero for the mass and the inverse mass. A static body has zero velocity. Static bodies do not collide with other static or kinematic bodies.</p>
<p><a class="el" href="group__body.html#gga74ddb02261648c2bff691a866b5c03e0a1b79458529f906fbf58858ab9508b985" title="zero mass, velocity set by user, moved by solver">b2_kinematicBody</a>: A kinematic body moves under simulation according to its velocity. Kinematic bodies do not respond to forces. A kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass, however, Box2D stores zero for the mass and the inverse mass. Kinematic bodies do not collide with other kinematic or static bodies. Generally you should use a kinematic body if you want a shape to be animated and not affected by forces or collisions.</p>
<p><a class="el" href="group__body.html#gga74ddb02261648c2bff691a866b5c03e0a65cfde8d03fe7855d91759842840ef40" title="positive mass, velocity determined by forces, moved by solver">b2_dynamicBody</a>: A dynamic body is fully simulated and moves according to forces and torques. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.</p>
<blockquote class="doxtable">
<p><b>Caution</b>: Generally you should not set the transform on bodies after creation. Box2D treats this as a teleport and may result in undesirable behavior and/or performance problems. </p>
</blockquote>
<p>Bodies carry shapes and moves them around in the world. Bodies are always rigid bodies in Box2D. That means that two shapes attached to the same rigid body never move relative to each other and shapes attached to the same body don't collide.</p>
<p>Shapes have collision geometry and density. Normally, bodies acquire their mass properties from the shapes. However, you can override the mass properties after a body is constructed.</p>
<p>You usually keep ids to all the bodies you create. This way you can query the body positions to update the positions of your graphical entities. You should also keep body ids so you can destroy them when you are done with them.</p>
<h2><a class="anchor" id="autotoc_md56"></a>
Body Definition</h2>
<p>Before a body is created you must create a body definition (<code><a class="el" href="group__body.html#structb2_body_def" title="A body definition holds all the data needed to construct a rigid body.">b2BodyDef</a></code>). The body definition holds the data needed to create and initialize a body correctly.</p>
<p>Because Box2D uses a C API, a function is provided to create a default body definition.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__body.html#structb2_body_def">b2BodyDef</a> myBodyDef = <a class="code hl_function" href="group__body.html#ga853e18f389eabf0e8cef10a81407e219">b2DefaultBodyDef</a>();</div>
<div class="ttc" id="agroup__body_html_ga853e18f389eabf0e8cef10a81407e219"><div class="ttname"><a href="group__body.html#ga853e18f389eabf0e8cef10a81407e219">b2DefaultBodyDef</a></div><div class="ttdeci">b2BodyDef b2DefaultBodyDef(void)</div><div class="ttdoc">Use this to initialize your body definition.</div></div>
<div class="ttc" id="agroup__body_html_structb2_body_def"><div class="ttname"><a href="group__body.html#structb2_body_def">b2BodyDef</a></div><div class="ttdoc">A body definition holds all the data needed to construct a rigid body.</div><div class="ttdef"><b>Definition</b> types.h:178</div></div>
</div><!-- fragment --><p>This ensures the body definition is valid and this initialization is <b>mandatory</b>.</p>
<p>Box2D copies the data out of the body definition; it does not keep a pointer to the body definition. This means you can recycle a body definition to create multiple bodies.</p>
<p>Let's go over some of the key members of the body definition.</p>
<h2><a class="anchor" id="autotoc_md57"></a>
Body Type</h2>
<p>As discussed previously, there are three different body types: static, kinematic, and dynamic. b2_staticBody is the default. You should establish the body type at creation because changing the body type later is expensive.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__body.html#structb2_body_def">b2BodyDef</a> bodyDef;</div>
<div class="line">bodyDef.<a class="code hl_variable" href="group__body.html#a89cc3ad1873908042b002147b3861381">type</a> = <a class="code hl_enumvalue" href="group__body.html#gga74ddb02261648c2bff691a866b5c03e0a65cfde8d03fe7855d91759842840ef40">b2_dynamicBody</a>;</div>
<div class="ttc" id="agroup__body_html_a89cc3ad1873908042b002147b3861381"><div class="ttname"><a href="group__body.html#a89cc3ad1873908042b002147b3861381">b2BodyDef::type</a></div><div class="ttdeci">b2BodyType type</div><div class="ttdoc">The body type: static, kinematic, or dynamic.</div><div class="ttdef"><b>Definition</b> types.h:180</div></div>
<div class="ttc" id="agroup__body_html_gga74ddb02261648c2bff691a866b5c03e0a65cfde8d03fe7855d91759842840ef40"><div class="ttname"><a href="group__body.html#gga74ddb02261648c2bff691a866b5c03e0a65cfde8d03fe7855d91759842840ef40">b2_dynamicBody</a></div><div class="ttdeci">@ b2_dynamicBody</div><div class="ttdoc">positive mass, velocity determined by forces, moved by solver</div><div class="ttdef"><b>Definition</b> types.h:166</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md58"></a>
Position and Angle</h2>
<p>You can initialize the body position and angle in the body definition. This has far better performance than creating the body at the world origin and then moving the body.</p>
<blockquote class="doxtable">
<p><b>Caution</b>: Do not create a body at the origin and then move it. If you create several bodies at the origin, then performance will suffer. </p>
</blockquote>
<p>A body has two main points of interest. The first point is the body's origin. Shapes and joints are attached relative to the body's origin. The second point of interest is the center of mass. The center of mass is determined from the mass distribution of the attached shapes or is explicitly set using <code><a class="el" href="group__geometry.html#structb2_mass_data" title="This holds the mass data computed for a shape.">b2MassData</a></code>. Much of Box2D's internal computations use the center of mass position. For example the body stores the linear velocity for the center of mass, not the body origin.</p>
<div class="image">
<object type="image/svg+xml" data="center_of_mass.svg" style="pointer-events: none;"></object>
<div class="caption">
Body Origin and Center of Mass</div></div>
    <p>When you are building the body definition, you may not know where the center of mass is located. Therefore you specify the position of the body's origin. You may also specify the body's angle in radians. If you later change the mass properties of the body, then the center of mass may move on the body, but the origin position and body angle does not change and the attached shapes and joints do not move.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__body.html#structb2_body_def">b2BodyDef</a> bodyDef = <a class="code hl_function" href="group__body.html#ga853e18f389eabf0e8cef10a81407e219">b2DefaultBodyDef</a>();</div>
<div class="line">bodyDef.<a class="code hl_variable" href="group__body.html#a680cadc09ad6cf4b3366cbf0914c648b">position</a> = (<a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a>){0.0f, 2.0f};</div>
<div class="line">bodyDef.angle = 0.25f * b2_pi;</div>
<div class="ttc" id="agroup__body_html_a680cadc09ad6cf4b3366cbf0914c648b"><div class="ttname"><a href="group__body.html#a680cadc09ad6cf4b3366cbf0914c648b">b2BodyDef::position</a></div><div class="ttdeci">b2Vec2 position</div><div class="ttdoc">The initial world position of the body.</div><div class="ttdef"><b>Definition</b> types.h:185</div></div>
</div><!-- fragment --><p>A rigid body is a frame of reference. You can define shapes and joints in that frame. Those shapes and joint anchors never move in the local frame of the body.</p>
<h2><a class="anchor" id="autotoc_md59"></a>
Damping</h2>
<p>Damping is used to reduce the world velocity of bodies. Damping is different than friction because friction only occurs with contact. Damping is not a replacement for friction and the two effects are used together.</p>
<p>Damping parameter are non-negative. Normally you will use a damping value between 0 and 1. I generally do not use linear damping because it makes bodies look like they are floating.</p>
<div class="fragment"><div class="line">bodyDef.<a class="code hl_variable" href="group__body.html#a973e312d5d95d2cd53c335ac3994d3ec">linearDamping</a> = 0.0f;</div>
<div class="line">bodyDef.<a class="code hl_variable" href="group__body.html#afc1f985f274c93ac99b4dea71e1d77cc">angularDamping</a> = 0.1f;</div>
<div class="ttc" id="agroup__body_html_a973e312d5d95d2cd53c335ac3994d3ec"><div class="ttname"><a href="group__body.html#a973e312d5d95d2cd53c335ac3994d3ec">b2BodyDef::linearDamping</a></div><div class="ttdeci">float linearDamping</div><div class="ttdoc">Linear damping is used to reduce the linear velocity.</div><div class="ttdef"><b>Definition</b> types.h:201</div></div>
<div class="ttc" id="agroup__body_html_afc1f985f274c93ac99b4dea71e1d77cc"><div class="ttname"><a href="group__body.html#afc1f985f274c93ac99b4dea71e1d77cc">b2BodyDef::angularDamping</a></div><div class="ttdeci">float angularDamping</div><div class="ttdoc">Angular damping is used to reduce the angular velocity.</div><div class="ttdef"><b>Definition</b> types.h:207</div></div>
</div><!-- fragment --><p>Damping is approximated to improve performance. At small damping values the damping effect is mostly independent of the time step. At larger damping values, the damping effect will vary with the time step. This is not an issue if you use a fixed time step (recommended).</p>
<p>Here's some math for the curious. A first-order different equation for velocity damping is:</p>
<p class="formulaDsp">
\[\frac{dv}{dt} + c v = 0
\]
</p>
<p>The solution with initial velocity \(v_0\) is   </p><p class="formulaDsp">
\[v = v_0 e^{-c t}
\]
</p>
<p>Across a single time step \(h\) the velocity evolves like so   </p><p class="formulaDsp">
\[v(t + h) = v_0 e^{-c (t + h)} = v_0 e^{-c t} e^{-c h} = v(t) e^{-c h}
\]
</p>
<p>Using the <a href="https://en.wikipedia.org/wiki/Pad%C3%A9_table">Pade approximation</a> for the exponential function gives the update formula:   </p><p class="formulaDsp">
\[v(t + h) \approx \frac{1}{1 + c h} v(t)
\]
</p>
<p>This is the formula used in the Box2D solver.</p>
<h2><a class="anchor" id="autotoc_md60"></a>
Gravity Scale</h2>
<p>You can use the gravity scale to adjust the gravity on a single body. Be careful though, a large gravity magnitude can decrease stability.</p>
<div class="fragment"><div class="line"><span class="comment">// Set the gravity scale to zero so this body will float</span></div>
<div class="line">bodyDef.<a class="code hl_variable" href="group__body.html#ac9e6956338f4bd35c162bf1ac8deddd6">gravityScale</a> = 0.0f;</div>
<div class="ttc" id="agroup__body_html_ac9e6956338f4bd35c162bf1ac8deddd6"><div class="ttname"><a href="group__body.html#ac9e6956338f4bd35c162bf1ac8deddd6">b2BodyDef::gravityScale</a></div><div class="ttdeci">float gravityScale</div><div class="ttdoc">Scale the gravity applied to this body. Non-dimensional.</div><div class="ttdef"><b>Definition</b> types.h:210</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md61"></a>
Sleep Parameters</h2>
<p>What does sleep mean? Well it is expensive to simulate bodies, so the less we have to simulate the better. When a body comes to rest we would like to stop simulating it.</p>
<p>When Box2D determines that a body (or group of bodies) has come to rest, the body enters a sleep state which has very little CPU overhead. If a body is awake and collides with a sleeping body, then the sleeping body wakes up. Bodies will also wake up if a joint or contact attached to them is destroyed. You can also wake a body manually.</p>
<p>The body definition lets you specify whether a body can sleep and whether a body is created sleeping.</p>
<div class="fragment"><div class="line">bodyDef.<a class="code hl_variable" href="group__body.html#af94e73a40a4c3c8f922ca1858521a30c">enableSleep</a> = <span class="keyword">true</span>;</div>
<div class="line">bodyDef.<a class="code hl_variable" href="group__body.html#af53f854f59108948d57c1f4820b2a8f7">isAwake</a> = <span class="keyword">true</span>;</div>
<div class="ttc" id="agroup__body_html_af53f854f59108948d57c1f4820b2a8f7"><div class="ttname"><a href="group__body.html#af53f854f59108948d57c1f4820b2a8f7">b2BodyDef::isAwake</a></div><div class="ttdeci">bool isAwake</div><div class="ttdoc">Is this body initially awake or sleeping?</div><div class="ttdef"><b>Definition</b> types.h:225</div></div>
<div class="ttc" id="agroup__body_html_af94e73a40a4c3c8f922ca1858521a30c"><div class="ttname"><a href="group__body.html#af94e73a40a4c3c8f922ca1858521a30c">b2BodyDef::enableSleep</a></div><div class="ttdeci">bool enableSleep</div><div class="ttdoc">Set this flag to false if this body should never fall asleep.</div><div class="ttdef"><b>Definition</b> types.h:222</div></div>
</div><!-- fragment --><p>The <code>isAwake</code> flag is ignored if <code>enableSleep</code> is false.</p>
<h2><a class="anchor" id="autotoc_md62"></a>
Fixed Rotation</h2>
<p>You may want a rigid body, such as a character, to have a fixed rotation. Such a body does not rotate, even under load. You can use the fixed rotation setting to achieve this:</p>
<div class="fragment"><div class="line">bodyDef.<a class="code hl_variable" href="group__body.html#a273a51c57440a8884de5939d76b6e3ea">fixedRotation</a> = <span class="keyword">true</span>;</div>
<div class="ttc" id="agroup__body_html_a273a51c57440a8884de5939d76b6e3ea"><div class="ttname"><a href="group__body.html#a273a51c57440a8884de5939d76b6e3ea">b2BodyDef::fixedRotation</a></div><div class="ttdeci">bool fixedRotation</div><div class="ttdoc">Should this body be prevented from rotating? Useful for characters.</div><div class="ttdef"><b>Definition</b> types.h:228</div></div>
</div><!-- fragment --><p>The fixed rotation flag causes the rotational inertia and its inverse to be set to zero.</p>
<h2><a class="anchor" id="bullets"></a>
Bullets</h2>
<p>Game simulation usually generates a sequence of transforms that are played at some frame rate. This is called discrete simulation. In discrete simulation, rigid bodies can move by a large amount in one time step. If a physics engine doesn't account for the large motion, you may see some objects incorrectly pass through each other. This effect is called <em>tunneling</em>.</p>
<p>By default, Box2D uses continuous collision detection (CCD) to prevent dynamic bodies from tunneling through static bodies. This is done by sweeping shapes from their old position to their new positions. The engine looks for new collisions during the sweep and computes the time of impact (TOI) for these collisions. Bodies are moved to their first TOI at the end of the time step.</p>
<p>Normally CCD is not used between dynamic bodies. This is done to keep performance reasonable. In some game scenarios you need dynamic bodies to use CCD. For example, you may want to shoot a high speed bullet at a stack of dynamic bricks. Without CCD, the bullet might tunnel through the bricks.</p>
<p>Fast moving objects in Box2D can be configured as <em>bullets</em>. Bullets will perform CCD with all body types, but <b>not</b> other bullets. You should decide what bodies should be bullets based on your game design. If you decide a body should be treated as a bullet, use the following setting.</p>
<div class="fragment"><div class="line">bodyDef.<a class="code hl_variable" href="group__body.html#aed1149c1b44596d5b3bb8208fdb95afa">isBullet</a> = <span class="keyword">true</span>;</div>
<div class="ttc" id="agroup__body_html_aed1149c1b44596d5b3bb8208fdb95afa"><div class="ttname"><a href="group__body.html#aed1149c1b44596d5b3bb8208fdb95afa">b2BodyDef::isBullet</a></div><div class="ttdeci">bool isBullet</div><div class="ttdoc">Treat this body as high speed object that performs continuous collision detection against dynamic and...</div><div class="ttdef"><b>Definition</b> types.h:234</div></div>
</div><!-- fragment --><p>The bullet flag only affects dynamic bodies. I recommend using bullets sparingly.</p>
<h2><a class="anchor" id="autotoc_md63"></a>
Disabling</h2>
<p>You may wish a body to be created but not participate in collision or simulation. This state is similar to sleeping except the body will not be woken by other bodies and the body's shapes will not collide with anything. This means the body will not participate in collisions, ray casts, etc.</p>
<p>You can create a body as disabled and later enable it.</p>
<div class="fragment"><div class="line">bodyDef.<a class="code hl_variable" href="group__body.html#a86763af259091cef9fad8fab0cc60ec6">isEnabled</a> = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Later ...</span></div>
<div class="line"><a class="code hl_function" href="group__body.html#ga919d3782fa898a9be3cabb80fbceef2a">b2Body_Enable</a>(myBodyId);</div>
<div class="ttc" id="agroup__body_html_a86763af259091cef9fad8fab0cc60ec6"><div class="ttname"><a href="group__body.html#a86763af259091cef9fad8fab0cc60ec6">b2BodyDef::isEnabled</a></div><div class="ttdeci">bool isEnabled</div><div class="ttdoc">Used to disable a body. A disabled body does not move or collide.</div><div class="ttdef"><b>Definition</b> types.h:237</div></div>
<div class="ttc" id="agroup__body_html_ga919d3782fa898a9be3cabb80fbceef2a"><div class="ttname"><a href="group__body.html#ga919d3782fa898a9be3cabb80fbceef2a">b2Body_Enable</a></div><div class="ttdeci">B2_API void b2Body_Enable(b2BodyId bodyId)</div><div class="ttdoc">Enable a body by adding it to the simulation. This is expensive.</div></div>
</div><!-- fragment --><p>Joints may be connected to disabled bodies. These joints will not be simulated. You should be careful when you enable a body that its joints are not distorted.</p>
<p>Note that enabling a body is almost as expensive as creating the body from scratch. So you should not use body disabling for streaming worlds. Instead, use creation/destruction for streaming worlds to save memory.</p>
<p>Body disabling is a convenience and is generally not good for performance.</p>
<h2><a class="anchor" id="autotoc_md64"></a>
User Data</h2>
<p>User data is a void pointer. This gives you a hook to link your application objects to bodies. You should be consistent to use the same object type for all body user data.</p>
<div class="fragment"><div class="line">bodyDef.<a class="code hl_variable" href="group__body.html#ae457dd1d39be09945eace6061121be29">userData</a> = &amp;myGameObject;</div>
<div class="ttc" id="agroup__body_html_ae457dd1d39be09945eace6061121be29"><div class="ttname"><a href="group__body.html#ae457dd1d39be09945eace6061121be29">b2BodyDef::userData</a></div><div class="ttdeci">void * userData</div><div class="ttdoc">Use this to store application specific body data.</div><div class="ttdef"><b>Definition</b> types.h:219</div></div>
</div><!-- fragment --><p>This is useful when you receive results from a query such as a ray-cast or event and you want to get back to your game object. You can acquire the use data from a body using <code><a class="el" href="group__body.html#ga07ef3ee098cf96750c8b2c151ac93a05" title="Get the user data stored in a body.">b2Body_GetUserData()</a></code>.</p>
<h2><a class="anchor" id="autotoc_md65"></a>
Body Lifetime</h2>
<p>Bodies are created and destroyed using a world id. This lets the world create the body with an efficient allocator and add the body to the world data structure.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__id.html#structb2_body_id">b2BodyId</a> myBodyId = <a class="code hl_function" href="group__body.html#ga61874d79bebe9baea67dffef53f840e0">b2CreateBody</a>(myWorldId, &amp;bodyDef);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... do stuff ...</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__body.html#ga89cb8fceace5f31a1e3ac28e390b18b0">b2DestroyBody</a>(myBodyId);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Nullify body id for safety</span></div>
<div class="line">myBodyId = b2_nullBodyId;</div>
<div class="ttc" id="agroup__body_html_ga89cb8fceace5f31a1e3ac28e390b18b0"><div class="ttname"><a href="group__body.html#ga89cb8fceace5f31a1e3ac28e390b18b0">b2DestroyBody</a></div><div class="ttdeci">B2_API void b2DestroyBody(b2BodyId bodyId)</div><div class="ttdoc">Destroy a rigid body given an id.</div></div>
</div><!-- fragment --><p>Box2D does not keep a reference to the body definition or any of the data it holds (except user data pointers). So you can create temporary body definitions and reuse the same body definitions.</p>
<p>Box2D allows you to avoid destroying bodies by destroying the world directly using <code><a class="el" href="group__world.html#ga894e7f6f1fca04c2428b69e35f16b46f" title="Destroy a world.">b2DestroyWorld()</a></code>, which does all the cleanup work for you. However, you should be mindful to nullify body ids that you keep in your application.</p>
<p>When you destroy a body, the attached shapes and joints are automatically destroyed. This has important implications for how you manage shape and joint ids. You should nullify these ids after destroying a body.</p>
<h2><a class="anchor" id="autotoc_md66"></a>
Using a Body</h2>
<p>After creating a body, there are many operations you can perform on the body. These include setting mass properties, accessing position and velocity, applying forces, and transforming points and vectors.</p>
<h2><a class="anchor" id="autotoc_md67"></a>
Mass Data</h2>
<p>A body has mass (scalar), center of mass (2-vector), and rotational inertia (scalar). For static bodies, the mass and rotational inertia are set to zero. When a body has fixed rotation, its rotational inertia is zero.</p>
<p>Normally the mass properties of a body are established automatically when shapes are added to the body. You can also adjust the mass of a body at run-time. This is usually done when you have special game scenarios that require altering the mass.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_mass_data">b2MassData</a> myMassData;</div>
<div class="line">myMassData.<a class="code hl_variable" href="group__geometry.html#a28306cd337e0a58f07ad21648367e35b">mass</a> = 10.0f;</div>
<div class="line">myMassData.<a class="code hl_variable" href="group__geometry.html#a1d59bebc7030c4dded0c2febc57ebdd7">center</a> = (<a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a>){0.0f, 0.0f};</div>
<div class="line">myMassData.<a class="code hl_variable" href="group__geometry.html#afef6d5063a10b4cf60ee3b2976544e07">rotationalInertia</a> = 100.0f;</div>
<div class="line"><a class="code hl_function" href="group__body.html#ga018d25c9acc6675389f6386f37b2a245">b2Body_SetMassData</a>(myBodyId, myMassData);</div>
<div class="ttc" id="agroup__body_html_ga018d25c9acc6675389f6386f37b2a245"><div class="ttname"><a href="group__body.html#ga018d25c9acc6675389f6386f37b2a245">b2Body_SetMassData</a></div><div class="ttdeci">B2_API void b2Body_SetMassData(b2BodyId bodyId, b2MassData massData)</div><div class="ttdoc">Override the body&#39;s mass properties.</div></div>
<div class="ttc" id="agroup__geometry_html_a1d59bebc7030c4dded0c2febc57ebdd7"><div class="ttname"><a href="group__geometry.html#a1d59bebc7030c4dded0c2febc57ebdd7">b2MassData::center</a></div><div class="ttdeci">b2Vec2 center</div><div class="ttdoc">The position of the shape&#39;s centroid relative to the shape&#39;s origin.</div><div class="ttdef"><b>Definition</b> collision.h:97</div></div>
<div class="ttc" id="agroup__geometry_html_a28306cd337e0a58f07ad21648367e35b"><div class="ttname"><a href="group__geometry.html#a28306cd337e0a58f07ad21648367e35b">b2MassData::mass</a></div><div class="ttdeci">float mass</div><div class="ttdoc">The mass of the shape, usually in kilograms.</div><div class="ttdef"><b>Definition</b> collision.h:94</div></div>
<div class="ttc" id="agroup__geometry_html_afef6d5063a10b4cf60ee3b2976544e07"><div class="ttname"><a href="group__geometry.html#afef6d5063a10b4cf60ee3b2976544e07">b2MassData::rotationalInertia</a></div><div class="ttdeci">float rotationalInertia</div><div class="ttdoc">The rotational inertia of the shape about the local origin.</div><div class="ttdef"><b>Definition</b> collision.h:100</div></div>
<div class="ttc" id="agroup__geometry_html_structb2_mass_data"><div class="ttname"><a href="group__geometry.html#structb2_mass_data">b2MassData</a></div><div class="ttdoc">This holds the mass data computed for a shape.</div><div class="ttdef"><b>Definition</b> collision.h:92</div></div>
</div><!-- fragment --><p>After setting a body's mass directly, you may wish to revert to the mass determined by the shapes. You can do this with:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__body.html#ga4b13599263b8f51ddba9a89c30c6fd0c">b2Body_ApplyMassFromShapes</a>(myBodyId);</div>
<div class="ttc" id="agroup__body_html_ga4b13599263b8f51ddba9a89c30c6fd0c"><div class="ttname"><a href="group__body.html#ga4b13599263b8f51ddba9a89c30c6fd0c">b2Body_ApplyMassFromShapes</a></div><div class="ttdeci">B2_API void b2Body_ApplyMassFromShapes(b2BodyId bodyId)</div><div class="ttdoc">This update the mass properties to the sum of the mass properties of the shapes.</div></div>
</div><!-- fragment --><p>The body's mass data is available through the following functions:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> mass = <a class="code hl_function" href="group__body.html#ga3a3ddf728694e20b016589ce6852c8a0">b2Body_GetMass</a>(myBodyId);</div>
<div class="line"><span class="keywordtype">float</span> inertia = <a class="code hl_function" href="group__body.html#gae82613b4c0fc5b155b842831370481e3">b2Body_GetRotationalInertia</a>(myBodyId);</div>
<div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> localCenter <a class="code hl_function" href="group__body.html#ga885ef73452ffbe73093497cafa7e75a0">b2Body_GetLocalCenterOfMass</a>(myBodyId);</div>
<div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_mass_data">b2MassData</a> massData = <a class="code hl_function" href="group__body.html#ga9f2bad9fd156b42d45f89c4a4b0b353c">b2Body_GetMassData</a>(myBodyId);</div>
<div class="ttc" id="agroup__body_html_ga3a3ddf728694e20b016589ce6852c8a0"><div class="ttname"><a href="group__body.html#ga3a3ddf728694e20b016589ce6852c8a0">b2Body_GetMass</a></div><div class="ttdeci">B2_API float b2Body_GetMass(b2BodyId bodyId)</div><div class="ttdoc">Get the mass of the body, usually in kilograms.</div></div>
<div class="ttc" id="agroup__body_html_ga885ef73452ffbe73093497cafa7e75a0"><div class="ttname"><a href="group__body.html#ga885ef73452ffbe73093497cafa7e75a0">b2Body_GetLocalCenterOfMass</a></div><div class="ttdeci">B2_API b2Vec2 b2Body_GetLocalCenterOfMass(b2BodyId bodyId)</div><div class="ttdoc">Get the center of mass position of the body in local space.</div></div>
<div class="ttc" id="agroup__body_html_ga9f2bad9fd156b42d45f89c4a4b0b353c"><div class="ttname"><a href="group__body.html#ga9f2bad9fd156b42d45f89c4a4b0b353c">b2Body_GetMassData</a></div><div class="ttdeci">B2_API b2MassData b2Body_GetMassData(b2BodyId bodyId)</div><div class="ttdoc">Get the mass data for a body.</div></div>
<div class="ttc" id="agroup__body_html_gae82613b4c0fc5b155b842831370481e3"><div class="ttname"><a href="group__body.html#gae82613b4c0fc5b155b842831370481e3">b2Body_GetRotationalInertia</a></div><div class="ttdeci">B2_API float b2Body_GetRotationalInertia(b2BodyId bodyId)</div><div class="ttdoc">Get the rotational inertia of the body, usually in kg*m^2.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md68"></a>
State Information</h2>
<p>There are many aspects to the body's state. You can access this state data through the following functions:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__body.html#ga2345070eefc2b1176b5e70250736e786">b2Body_SetType</a>(myBodyId, <a class="code hl_enumvalue" href="group__body.html#gga74ddb02261648c2bff691a866b5c03e0a1b79458529f906fbf58858ab9508b985">b2_kinematicBody</a>);</div>
<div class="line"><a class="code hl_enumeration" href="group__body.html#ga74ddb02261648c2bff691a866b5c03e0">b2BodyType</a> bodyType = <a class="code hl_function" href="group__body.html#ga0169bdde8c89a173dff8921bd033a94f">b2Body_GetType</a>(myBodyId);</div>
<div class="line"><a class="code hl_function" href="group__body.html#ga19143dc627cc41ca4f7f2640de858e8c">b2Body_SetBullet</a>(myBodyId, <span class="keyword">true</span>);</div>
<div class="line"><span class="keywordtype">bool</span> isBullet = <a class="code hl_function" href="group__body.html#gad3ec0705d6f6724c5617eee5093cd7f5">b2Body_IsBullet</a>(myBodyId);</div>
<div class="line"><a class="code hl_function" href="group__body.html#ga848d244267c1003f031331b13ea36869">b2Body_EnableSleep</a>(myBodyId, <span class="keyword">false</span>);</div>
<div class="line"><span class="keywordtype">bool</span> isSleepEnabled = b2Body_IsSleepingEnabled(myBodyId);</div>
<div class="line"><a class="code hl_function" href="group__body.html#ga401edc0fdbe6945a9393e1a90af0d3db">b2Body_SetAwake</a>(myBodyId, <span class="keyword">true</span>);</div>
<div class="line"><span class="keywordtype">bool</span> isAwake = <a class="code hl_function" href="group__body.html#gad88f7df91abb71f2f8a7bc2f583d9409">b2Body_IsAwake</a>(myBodyId);</div>
<div class="line"><a class="code hl_function" href="group__body.html#ga669c794a50c1ee39db0514f11aaa2c7e">b2Body_Disable</a>(myBodyId);</div>
<div class="line"><a class="code hl_function" href="group__body.html#ga919d3782fa898a9be3cabb80fbceef2a">b2Body_Enable</a>(myBodyId);</div>
<div class="line"><span class="keywordtype">bool</span> isEnabled = <a class="code hl_function" href="group__body.html#ga64284c97df65d3f43afb10a2eed52577">b2Body_IsEnabled</a>(myBodyId);</div>
<div class="line"><a class="code hl_function" href="group__body.html#ga56a0288ef344a6737c6ee7e4153e75d5">b2Body_SetFixedRotation</a>(myBodyId, <span class="keyword">true</span>);</div>
<div class="line"><span class="keywordtype">bool</span> isFixedRotation = <a class="code hl_function" href="group__body.html#ga69585a860f36fb8eab5d086931d4fbc9">b2Body_IsFixedRotation</a>(myBodyId);</div>
<div class="ttc" id="agroup__body_html_ga0169bdde8c89a173dff8921bd033a94f"><div class="ttname"><a href="group__body.html#ga0169bdde8c89a173dff8921bd033a94f">b2Body_GetType</a></div><div class="ttdeci">B2_API b2BodyType b2Body_GetType(b2BodyId bodyId)</div><div class="ttdoc">Get the body type: static, kinematic, or dynamic.</div></div>
<div class="ttc" id="agroup__body_html_ga19143dc627cc41ca4f7f2640de858e8c"><div class="ttname"><a href="group__body.html#ga19143dc627cc41ca4f7f2640de858e8c">b2Body_SetBullet</a></div><div class="ttdeci">B2_API void b2Body_SetBullet(b2BodyId bodyId, bool flag)</div><div class="ttdoc">Set this body to be a bullet.</div></div>
<div class="ttc" id="agroup__body_html_ga2345070eefc2b1176b5e70250736e786"><div class="ttname"><a href="group__body.html#ga2345070eefc2b1176b5e70250736e786">b2Body_SetType</a></div><div class="ttdeci">B2_API void b2Body_SetType(b2BodyId bodyId, b2BodyType type)</div><div class="ttdoc">Change the body type.</div></div>
<div class="ttc" id="agroup__body_html_ga401edc0fdbe6945a9393e1a90af0d3db"><div class="ttname"><a href="group__body.html#ga401edc0fdbe6945a9393e1a90af0d3db">b2Body_SetAwake</a></div><div class="ttdeci">B2_API void b2Body_SetAwake(b2BodyId bodyId, bool awake)</div><div class="ttdoc">Wake a body from sleep.</div></div>
<div class="ttc" id="agroup__body_html_ga56a0288ef344a6737c6ee7e4153e75d5"><div class="ttname"><a href="group__body.html#ga56a0288ef344a6737c6ee7e4153e75d5">b2Body_SetFixedRotation</a></div><div class="ttdeci">B2_API void b2Body_SetFixedRotation(b2BodyId bodyId, bool flag)</div><div class="ttdoc">Set this body to have fixed rotation. This causes the mass to be reset in all cases.</div></div>
<div class="ttc" id="agroup__body_html_ga64284c97df65d3f43afb10a2eed52577"><div class="ttname"><a href="group__body.html#ga64284c97df65d3f43afb10a2eed52577">b2Body_IsEnabled</a></div><div class="ttdeci">B2_API bool b2Body_IsEnabled(b2BodyId bodyId)</div><div class="ttdoc">Returns true if this body is enabled.</div></div>
<div class="ttc" id="agroup__body_html_ga669c794a50c1ee39db0514f11aaa2c7e"><div class="ttname"><a href="group__body.html#ga669c794a50c1ee39db0514f11aaa2c7e">b2Body_Disable</a></div><div class="ttdeci">B2_API void b2Body_Disable(b2BodyId bodyId)</div><div class="ttdoc">Disable a body by removing it completely from the simulation. This is expensive.</div></div>
<div class="ttc" id="agroup__body_html_ga69585a860f36fb8eab5d086931d4fbc9"><div class="ttname"><a href="group__body.html#ga69585a860f36fb8eab5d086931d4fbc9">b2Body_IsFixedRotation</a></div><div class="ttdeci">B2_API bool b2Body_IsFixedRotation(b2BodyId bodyId)</div><div class="ttdoc">Does this body have fixed rotation?</div></div>
<div class="ttc" id="agroup__body_html_ga74ddb02261648c2bff691a866b5c03e0"><div class="ttname"><a href="group__body.html#ga74ddb02261648c2bff691a866b5c03e0">b2BodyType</a></div><div class="ttdeci">b2BodyType</div><div class="ttdoc">The body simulation type.</div><div class="ttdef"><b>Definition</b> types.h:158</div></div>
<div class="ttc" id="agroup__body_html_ga848d244267c1003f031331b13ea36869"><div class="ttname"><a href="group__body.html#ga848d244267c1003f031331b13ea36869">b2Body_EnableSleep</a></div><div class="ttdeci">B2_API void b2Body_EnableSleep(b2BodyId bodyId, bool enableSleep)</div><div class="ttdoc">Enable or disable sleeping for this body. If sleeping is disabled the body will wake.</div></div>
<div class="ttc" id="agroup__body_html_gad3ec0705d6f6724c5617eee5093cd7f5"><div class="ttname"><a href="group__body.html#gad3ec0705d6f6724c5617eee5093cd7f5">b2Body_IsBullet</a></div><div class="ttdeci">B2_API bool b2Body_IsBullet(b2BodyId bodyId)</div><div class="ttdoc">Is this body a bullet?</div></div>
<div class="ttc" id="agroup__body_html_gad88f7df91abb71f2f8a7bc2f583d9409"><div class="ttname"><a href="group__body.html#gad88f7df91abb71f2f8a7bc2f583d9409">b2Body_IsAwake</a></div><div class="ttdeci">B2_API bool b2Body_IsAwake(b2BodyId bodyId)</div></div>
<div class="ttc" id="agroup__body_html_gga74ddb02261648c2bff691a866b5c03e0a1b79458529f906fbf58858ab9508b985"><div class="ttname"><a href="group__body.html#gga74ddb02261648c2bff691a866b5c03e0a1b79458529f906fbf58858ab9508b985">b2_kinematicBody</a></div><div class="ttdeci">@ b2_kinematicBody</div><div class="ttdoc">zero mass, velocity set by user, moved by solver</div><div class="ttdef"><b>Definition</b> types.h:163</div></div>
</div><!-- fragment --><p>Please see the comments on these functions for more details.</p>
<h2><a class="anchor" id="autotoc_md69"></a>
Position and Velocity</h2>
<p>You can access the position and rotation of a body. This is common when rendering your associated game object. You can also set the position and angle, although this is less common since you will normally use Box2D to simulate movement.</p>
<p>Keep in mind that the Box2D interface uses <em>radians</em>.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__body.html#ga7f00205c13588910fa8e8806bef4bf6d">b2Body_SetTransform</a>(myBodyId, position, rotation);</div>
<div class="line"><a class="code hl_struct" href="group__math.html#structb2_transform">b2Transform</a> transform = <a class="code hl_function" href="group__body.html#ga90de5f03e362486bea0751b4e33d8b95">b2Body_GetTransform</a>(myBodyId);</div>
<div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> position = <a class="code hl_function" href="group__body.html#ga410082a8b036e98a3896782ee4629a4a">b2Body_GetPosition</a>(myBodyId);</div>
<div class="line"><a class="code hl_struct" href="group__math.html#structb2_rot">b2Rot</a> rotation = <a class="code hl_function" href="group__body.html#gaa6192f44fd9bcc2bf73c204269c18566">b2Body_GetRotation</a>(myBodyId);</div>
<div class="line"><span class="keywordtype">float</span> angleInRadians = <a class="code hl_function" href="group__math.html#ga103472b4bc6a9e0cb8009bec6389ee67">b2Rot_GetAngle</a>(rotation);</div>
<div class="ttc" id="agroup__body_html_ga410082a8b036e98a3896782ee4629a4a"><div class="ttname"><a href="group__body.html#ga410082a8b036e98a3896782ee4629a4a">b2Body_GetPosition</a></div><div class="ttdeci">B2_API b2Vec2 b2Body_GetPosition(b2BodyId bodyId)</div><div class="ttdoc">Get the world position of a body. This is the location of the body origin.</div></div>
<div class="ttc" id="agroup__body_html_ga7f00205c13588910fa8e8806bef4bf6d"><div class="ttname"><a href="group__body.html#ga7f00205c13588910fa8e8806bef4bf6d">b2Body_SetTransform</a></div><div class="ttdeci">B2_API void b2Body_SetTransform(b2BodyId bodyId, b2Vec2 position, b2Rot rotation)</div><div class="ttdoc">Set the world transform of a body.</div></div>
<div class="ttc" id="agroup__body_html_ga90de5f03e362486bea0751b4e33d8b95"><div class="ttname"><a href="group__body.html#ga90de5f03e362486bea0751b4e33d8b95">b2Body_GetTransform</a></div><div class="ttdeci">B2_API b2Transform b2Body_GetTransform(b2BodyId bodyId)</div><div class="ttdoc">Get the world transform of a body.</div></div>
<div class="ttc" id="agroup__body_html_gaa6192f44fd9bcc2bf73c204269c18566"><div class="ttname"><a href="group__body.html#gaa6192f44fd9bcc2bf73c204269c18566">b2Body_GetRotation</a></div><div class="ttdeci">B2_API b2Rot b2Body_GetRotation(b2BodyId bodyId)</div><div class="ttdoc">Get the world rotation of a body as a cosine/sine pair (complex number)</div></div>
<div class="ttc" id="agroup__math_html_ga103472b4bc6a9e0cb8009bec6389ee67"><div class="ttname"><a href="group__math.html#ga103472b4bc6a9e0cb8009bec6389ee67">b2Rot_GetAngle</a></div><div class="ttdeci">float b2Rot_GetAngle(b2Rot q)</div><div class="ttdoc">Get the angle in radians in the range [-pi, pi].</div><div class="ttdef"><b>Definition</b> math_functions.h:410</div></div>
<div class="ttc" id="agroup__math_html_structb2_rot"><div class="ttname"><a href="group__math.html#structb2_rot">b2Rot</a></div><div class="ttdoc">2D rotation This is similar to using a complex number for rotation</div><div class="ttdef"><b>Definition</b> math_functions.h:38</div></div>
<div class="ttc" id="agroup__math_html_structb2_transform"><div class="ttname"><a href="group__math.html#structb2_transform">b2Transform</a></div><div class="ttdoc">A 2D rigid transform.</div><div class="ttdef"><b>Definition</b> math_functions.h:45</div></div>
</div><!-- fragment --><p>You can access the center of mass position in local and world coordinates. Much of the internal simulation in Box2D uses the center of mass. However, you should normally not need to access it. Instead you will usually work with the body transform. For example, you may have a body that is square. The body origin might be a corner of the square, while the center of mass is located at the center of the square.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> worldCenter = <a class="code hl_function" href="group__body.html#ga000c8766f33022db931d6c2d8e65a115">b2Body_GetWorldCenterOfMass</a>(myBodyId);</div>
<div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> localCenter = <a class="code hl_function" href="group__body.html#ga885ef73452ffbe73093497cafa7e75a0">b2Body_GetLocalCenterOfMass</a>(myBodyId);</div>
<div class="ttc" id="agroup__body_html_ga000c8766f33022db931d6c2d8e65a115"><div class="ttname"><a href="group__body.html#ga000c8766f33022db931d6c2d8e65a115">b2Body_GetWorldCenterOfMass</a></div><div class="ttdeci">B2_API b2Vec2 b2Body_GetWorldCenterOfMass(b2BodyId bodyId)</div><div class="ttdoc">Get the center of mass position of the body in world space.</div></div>
</div><!-- fragment --><p>You can access the linear and angular velocity. The linear velocity is for the center of mass. Therefore, the linear velocity may change if the mass properties change. Since Box2D uses radians, the angular velocity is in radians per second.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> linearVelocity = <a class="code hl_function" href="group__body.html#gac8035cf726a6c9449495da06631d7505">b2Body_GetLinearVelocity</a>(myBodyId);</div>
<div class="line"><span class="keywordtype">float</span> angularVelocity = <a class="code hl_function" href="group__body.html#ga456d4394302baaf6bc640802f44bb22a">b2Body_GetAngularVelocity</a>(myBodyId);</div>
<div class="ttc" id="agroup__body_html_ga456d4394302baaf6bc640802f44bb22a"><div class="ttname"><a href="group__body.html#ga456d4394302baaf6bc640802f44bb22a">b2Body_GetAngularVelocity</a></div><div class="ttdeci">B2_API float b2Body_GetAngularVelocity(b2BodyId bodyId)</div><div class="ttdoc">Get the angular velocity of a body in radians per second.</div></div>
<div class="ttc" id="agroup__body_html_gac8035cf726a6c9449495da06631d7505"><div class="ttname"><a href="group__body.html#gac8035cf726a6c9449495da06631d7505">b2Body_GetLinearVelocity</a></div><div class="ttdeci">B2_API b2Vec2 b2Body_GetLinearVelocity(b2BodyId bodyId)</div><div class="ttdoc">Get the linear velocity of a body&#39;s center of mass. Usually in meters per second.</div></div>
</div><!-- fragment --><p>You can drive a body to a specific transform. This is useful for kinematic bodies.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> targetPosition = {42.0f, -100.0f};</div>
<div class="line"><a class="code hl_struct" href="group__math.html#structb2_rot">b2Rot</a> targetRotation = <a class="code hl_function" href="group__math.html#gaccebe20249e16f2d61657c9d532278ea">b2MakeRot</a>(<a class="code hl_define" href="group__math.html#gad8c9a670f81e539d51761c8674799fa9">B2_PI</a>);</div>
<div class="line"><a class="code hl_struct" href="group__math.html#structb2_transform">b2Transform</a> target = {targetPosition, targetRotation};</div>
<div class="line"><span class="keywordtype">float</span> timeStep = 1.0f / 60.0f;</div>
<div class="line"><a class="code hl_function" href="group__body.html#ga834e3efbe8f7730e368be97ef18df765">b2Body_SetTargetTransform</a>(myBodyId, target, timeStep);</div>
<div class="ttc" id="agroup__body_html_ga834e3efbe8f7730e368be97ef18df765"><div class="ttname"><a href="group__body.html#ga834e3efbe8f7730e368be97ef18df765">b2Body_SetTargetTransform</a></div><div class="ttdeci">B2_API void b2Body_SetTargetTransform(b2BodyId bodyId, b2Transform target, float timeStep)</div><div class="ttdoc">Set the velocity to reach the given transform after a given time step.</div></div>
<div class="ttc" id="agroup__math_html_gaccebe20249e16f2d61657c9d532278ea"><div class="ttname"><a href="group__math.html#gaccebe20249e16f2d61657c9d532278ea">b2MakeRot</a></div><div class="ttdeci">b2Rot b2MakeRot(float radians)</div><div class="ttdoc">Make a rotation using an angle in radians.</div><div class="ttdef"><b>Definition</b> math_functions.h:355</div></div>
<div class="ttc" id="agroup__math_html_gad8c9a670f81e539d51761c8674799fa9"><div class="ttname"><a href="group__math.html#gad8c9a670f81e539d51761c8674799fa9">B2_PI</a></div><div class="ttdeci">#define B2_PI</div><div class="ttdoc">https://en.wikipedia.org/wiki/Pi</div><div class="ttdef"><b>Definition</b> math_functions.h:79</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md70"></a>
Forces and Impulses</h2>
<p>You can apply forces, torques, and impulses to a body. When you apply a force or an impulse, you can provide a world point where the load is applied. This often results in a torque about the center of mass.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__body.html#ga350c6c2a7f3019e8f55ae4d34f614e7d">b2Body_ApplyForce</a>(myBodyId, force, worldPoint, wake);</div>
<div class="line"><a class="code hl_function" href="group__body.html#ga64a4b66b329162ead4d46a1f83323a51">b2Body_ApplyTorque</a>(myBodyId, torque, wake);</div>
<div class="line"><a class="code hl_function" href="group__body.html#ga0c352ed887209142a9e82035c133a4f2">b2Body_ApplyLinearImpulse</a>(myBodyId, linearImpulse, worldPoint, wake);</div>
<div class="line"><a class="code hl_function" href="group__body.html#ga6edbf076a5022ee884c484093f8cf2f3">b2Body_ApplyAngularImpulse</a>(myBodyId, angularImpulse, wake);</div>
<div class="ttc" id="agroup__body_html_ga0c352ed887209142a9e82035c133a4f2"><div class="ttname"><a href="group__body.html#ga0c352ed887209142a9e82035c133a4f2">b2Body_ApplyLinearImpulse</a></div><div class="ttdeci">B2_API void b2Body_ApplyLinearImpulse(b2BodyId bodyId, b2Vec2 impulse, b2Vec2 point, bool wake)</div><div class="ttdoc">Apply an impulse at a point.</div></div>
<div class="ttc" id="agroup__body_html_ga350c6c2a7f3019e8f55ae4d34f614e7d"><div class="ttname"><a href="group__body.html#ga350c6c2a7f3019e8f55ae4d34f614e7d">b2Body_ApplyForce</a></div><div class="ttdeci">B2_API void b2Body_ApplyForce(b2BodyId bodyId, b2Vec2 force, b2Vec2 point, bool wake)</div><div class="ttdoc">Apply a force at a world point.</div></div>
<div class="ttc" id="agroup__body_html_ga64a4b66b329162ead4d46a1f83323a51"><div class="ttname"><a href="group__body.html#ga64a4b66b329162ead4d46a1f83323a51">b2Body_ApplyTorque</a></div><div class="ttdeci">B2_API void b2Body_ApplyTorque(b2BodyId bodyId, float torque, bool wake)</div><div class="ttdoc">Apply a torque.</div></div>
<div class="ttc" id="agroup__body_html_ga6edbf076a5022ee884c484093f8cf2f3"><div class="ttname"><a href="group__body.html#ga6edbf076a5022ee884c484093f8cf2f3">b2Body_ApplyAngularImpulse</a></div><div class="ttdeci">B2_API void b2Body_ApplyAngularImpulse(b2BodyId bodyId, float impulse, bool wake)</div><div class="ttdoc">Apply an angular impulse.</div></div>
</div><!-- fragment --><p>Applying a force, torque, or impulse optionally wakes the body. If you don't wake the body and it is asleep, then the force or impulse will be ignored.</p>
<p>You can also apply a force and linear impulse to the center of mass to avoid rotation.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__body.html#ga22ab3db0d5a9ab8b3d19ff1daa04cae7">b2Body_ApplyForceToCenter</a>(myBodyId, force, wake);</div>
<div class="line"><a class="code hl_function" href="group__body.html#gac2b96fe186668b4ff0754fb6ee15e43b">b2Body_ApplyLinearImpulseToCenter</a>(myBodyId, linearImpulse, wake);</div>
<div class="ttc" id="agroup__body_html_ga22ab3db0d5a9ab8b3d19ff1daa04cae7"><div class="ttname"><a href="group__body.html#ga22ab3db0d5a9ab8b3d19ff1daa04cae7">b2Body_ApplyForceToCenter</a></div><div class="ttdeci">B2_API void b2Body_ApplyForceToCenter(b2BodyId bodyId, b2Vec2 force, bool wake)</div><div class="ttdoc">Apply a force to the center of mass.</div></div>
<div class="ttc" id="agroup__body_html_gac2b96fe186668b4ff0754fb6ee15e43b"><div class="ttname"><a href="group__body.html#gac2b96fe186668b4ff0754fb6ee15e43b">b2Body_ApplyLinearImpulseToCenter</a></div><div class="ttdeci">B2_API void b2Body_ApplyLinearImpulseToCenter(b2BodyId bodyId, b2Vec2 impulse, bool wake)</div><div class="ttdoc">Apply an impulse to the center of mass.</div></div>
</div><!-- fragment --><blockquote class="doxtable">
<p><b>Caution</b>: Since Box2D uses sub-stepping, you should not apply a steady impulse for several frames. Instead you should apply a force which Box2D will spread out evenly across the sub-steps, resulting in smoother movement. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md71"></a>
Coordinate Transformations</h2>
<p>The body has some utility functions to help you transform points and vectors between local and world space. If you don't understand these concepts, I recommend reading "Essential Mathematics for Games and Interactive Applications" by Jim Van Verth and Lars Bishop.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> worldPoint = <a class="code hl_function" href="group__body.html#gad92a168eb3618448a336bfa88ac4d9a7">b2Body_GetWorldPoint</a>(myBodyId, localPoint);</div>
<div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> worldVector = <a class="code hl_function" href="group__body.html#gab3af2580ca7fa4efacc71f5cc17bfdbb">b2Body_GetWorldVector</a>(myBodyId, localVector);</div>
<div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> localPoint = <a class="code hl_function" href="group__body.html#gac10f227ccd433b997fe8158d0724f5b9">b2Body_GetLocalPoint</a>(myBodyId, worldPoint);</div>
<div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> localVector = <a class="code hl_function" href="group__body.html#ga983ef6f5815a611bbe6327f4ec7308b9">b2Body_GetLocalVector</a>(myBodyId, worldVector);</div>
<div class="ttc" id="agroup__body_html_ga983ef6f5815a611bbe6327f4ec7308b9"><div class="ttname"><a href="group__body.html#ga983ef6f5815a611bbe6327f4ec7308b9">b2Body_GetLocalVector</a></div><div class="ttdeci">B2_API b2Vec2 b2Body_GetLocalVector(b2BodyId bodyId, b2Vec2 worldVector)</div><div class="ttdoc">Get a local vector on a body given a world vector.</div></div>
<div class="ttc" id="agroup__body_html_gab3af2580ca7fa4efacc71f5cc17bfdbb"><div class="ttname"><a href="group__body.html#gab3af2580ca7fa4efacc71f5cc17bfdbb">b2Body_GetWorldVector</a></div><div class="ttdeci">B2_API b2Vec2 b2Body_GetWorldVector(b2BodyId bodyId, b2Vec2 localVector)</div><div class="ttdoc">Get a world vector on a body given a local vector.</div></div>
<div class="ttc" id="agroup__body_html_gac10f227ccd433b997fe8158d0724f5b9"><div class="ttname"><a href="group__body.html#gac10f227ccd433b997fe8158d0724f5b9">b2Body_GetLocalPoint</a></div><div class="ttdeci">B2_API b2Vec2 b2Body_GetLocalPoint(b2BodyId bodyId, b2Vec2 worldPoint)</div><div class="ttdoc">Get a local point on a body given a world point.</div></div>
<div class="ttc" id="agroup__body_html_gad92a168eb3618448a336bfa88ac4d9a7"><div class="ttname"><a href="group__body.html#gad92a168eb3618448a336bfa88ac4d9a7">b2Body_GetWorldPoint</a></div><div class="ttdeci">B2_API b2Vec2 b2Body_GetWorldPoint(b2BodyId bodyId, b2Vec2 localPoint)</div><div class="ttdoc">Get a world point on a body given a local point.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md72"></a>
Accessing Shapes and Joints</h2>
<p>You can access the shapes on a body. You can get the number of shapes first.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> shapeCount = <a class="code hl_function" href="group__body.html#ga4233df9ec70b6fa52f88061dab2a8d6a">b2Body_GetShapeCount</a>(myBodyId);</div>
<div class="ttc" id="agroup__body_html_ga4233df9ec70b6fa52f88061dab2a8d6a"><div class="ttname"><a href="group__body.html#ga4233df9ec70b6fa52f88061dab2a8d6a">b2Body_GetShapeCount</a></div><div class="ttdeci">B2_API int b2Body_GetShapeCount(b2BodyId bodyId)</div><div class="ttdoc">Get the number of shapes on this body.</div></div>
</div><!-- fragment --><p>If you have bodies with many shapes, you can allocate an array or if you know the number is limited you can use a fixed size array.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeIds[10];</div>
<div class="line"><span class="keywordtype">int</span> returnCount = <a class="code hl_function" href="group__body.html#gadbc3c6c788ec5dfa66f42dde6c91bc49">b2Body_GetShapes</a>(myBodyId, shapeIds, 10);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; returnCount; ++i)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeId = shapeIds[i];</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// do something with shapeId</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__body_html_gadbc3c6c788ec5dfa66f42dde6c91bc49"><div class="ttname"><a href="group__body.html#gadbc3c6c788ec5dfa66f42dde6c91bc49">b2Body_GetShapes</a></div><div class="ttdeci">B2_API int b2Body_GetShapes(b2BodyId bodyId, b2ShapeId *shapeArray, int capacity)</div><div class="ttdoc">Get the shape ids for all shapes on this body, up to the provided capacity.</div></div>
<div class="ttc" id="agroup__id_html_structb2_shape_id"><div class="ttname"><a href="group__id.html#structb2_shape_id">b2ShapeId</a></div><div class="ttdoc">Shape id references a shape instance. This should be treated as an opaque handle.</div><div class="ttdef"><b>Definition</b> id.h:53</div></div>
</div><!-- fragment --><p>You can similarly get an array of the joints on a body.</p>
<h2><a class="anchor" id="autotoc_md73"></a>
Body Events</h2>
<p>While you can gather transforms from all your bodies after every time step, this is inefficient. Many bodies may not have moved because they are sleeping. Also iterating across many bodies will have lots of cache misses.</p>
<p>Box2D provides <code><a class="el" href="group__events.html#structb2_body_events" title="Body events are buffered in the Box2D world and are available as event arrays after the time step is ...">b2BodyEvents</a></code> that you can access after every call to <code><a class="el" href="group__world.html#ga8441b35f0a5d67ccf40961a94d4941ef" title="Simulate a world for one time step.">b2World_Step()</a></code> to get an array of body movement events. Since this data is contiguous, it is cache friendly.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__events.html#structb2_body_events">b2BodyEvents</a> events = <a class="code hl_function" href="group__world.html#ga5e6ffdadb6a72f4435be858a0ac2b8c6">b2World_GetBodyEvents</a>(m_worldId);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; events.<a class="code hl_variable" href="group__events.html#afb339891814414b210217935d1a45d00">moveCount</a>; ++i)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_struct" href="group__events.html#structb2_body_move_event">b2BodyMoveEvent</a>* <span class="keyword">event</span> = events.<a class="code hl_variable" href="group__events.html#a9373881d53fab36e3620b703edadc629">moveEvents</a> + i;</div>
<div class="line">    MyGameObject* gameObject = <span class="keyword">event</span>-&gt;userData;</div>
<div class="line">    MoveGameObject(gameObject, event-&gt;transform);</div>
<div class="line">    <span class="keywordflow">if</span> (event-&gt;fellAsleep)</div>
<div class="line">    {</div>
<div class="line">        SleepGameObject(gameObject);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__events_html_a9373881d53fab36e3620b703edadc629"><div class="ttname"><a href="group__events.html#a9373881d53fab36e3620b703edadc629">b2BodyEvents::moveEvents</a></div><div class="ttdeci">b2BodyMoveEvent * moveEvents</div><div class="ttdoc">Array of move events.</div><div class="ttdef"><b>Definition</b> types.h:1144</div></div>
<div class="ttc" id="agroup__events_html_afb339891814414b210217935d1a45d00"><div class="ttname"><a href="group__events.html#afb339891814414b210217935d1a45d00">b2BodyEvents::moveCount</a></div><div class="ttdeci">int moveCount</div><div class="ttdoc">Number of move events.</div><div class="ttdef"><b>Definition</b> types.h:1147</div></div>
<div class="ttc" id="agroup__events_html_structb2_body_events"><div class="ttname"><a href="group__events.html#structb2_body_events">b2BodyEvents</a></div><div class="ttdoc">Body events are buffered in the Box2D world and are available as event arrays after the time step is ...</div><div class="ttdef"><b>Definition</b> types.h:1142</div></div>
<div class="ttc" id="agroup__events_html_structb2_body_move_event"><div class="ttname"><a href="group__events.html#structb2_body_move_event">b2BodyMoveEvent</a></div><div class="ttdoc">Body move events triggered when a body moves.</div><div class="ttdef"><b>Definition</b> types.h:1131</div></div>
<div class="ttc" id="agroup__world_html_ga5e6ffdadb6a72f4435be858a0ac2b8c6"><div class="ttname"><a href="group__world.html#ga5e6ffdadb6a72f4435be858a0ac2b8c6">b2World_GetBodyEvents</a></div><div class="ttdeci">B2_API b2BodyEvents b2World_GetBodyEvents(b2WorldId worldId)</div><div class="ttdoc">Get the body events for the current time step. The event data is transient. Do not store a reference ...</div></div>
</div><!-- fragment --><p>The body event also indicates if the body fell asleep this time step. This might be useful to optimize your application.</p>
<h1><a class="anchor" id="autotoc_md74"></a>
Shapes</h1>
<p>A body may have zero or more shapes. A body with multiple shapes is sometimes called a <em>compound body.</em></p>
<p>Shapes hold the following:</p><ul>
<li>a shape primitive</li>
<li>density, friction, and restitution</li>
<li>collision filtering flags</li>
<li>parent body id</li>
<li>user data</li>
<li>sensor flag</li>
</ul>
<p>These are described in the following sections.</p>
<h2><a class="anchor" id="autotoc_md75"></a>
Shape Lifetime</h2>
<p>Shapes are created by initializing a shape definition and a shape primitive. These are passed to a creation function specific to each shape type.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__shape.html#structb2_shape_def">b2ShapeDef</a> shapeDef = <a class="code hl_function" href="group__shape.html#gab4ca752f5de1d27c953f3520bd8fcef1">b2DefaultShapeDef</a>();</div>
<div class="line">shapeDef.<a class="code hl_variable" href="group__shape.html#ab0ddf90317622a46ac9cb54e47342b54">density</a> = 10.0f;</div>
<div class="line">shapeDef.<a class="code hl_variable" href="group__shape.html#a965b7e4e4aafb33383ece1c9febb6c3b">material</a>.<a class="code hl_variable" href="group__shape.html#af164fd9a1f40ff4bb7936a5a9b030afc">friction</a> = 0.7f;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_polygon">b2Polygon</a> box = <a class="code hl_function" href="group__geometry.html#gad5fff23dd63ef099af09c0fb13fb41a3">b2MakeBox</a>(0.5f, 1.0f);</div>
<div class="line"><a class="code hl_struct" href="group__id.html#structb2_shape_id">b2ShapeId</a> myShapeId = <a class="code hl_function" href="group__shape.html#ga3e55037d832f0cbf30f467eea5c6107e">b2CreatePolygonShape</a>(myBodyId, &amp;shapeDef, &amp;box);</div>
<div class="ttc" id="agroup__geometry_html_gad5fff23dd63ef099af09c0fb13fb41a3"><div class="ttname"><a href="group__geometry.html#gad5fff23dd63ef099af09c0fb13fb41a3">b2MakeBox</a></div><div class="ttdeci">b2Polygon b2MakeBox(float halfWidth, float halfHeight)</div><div class="ttdoc">Make a box (rectangle) polygon, bypassing the need for a convex hull.</div></div>
<div class="ttc" id="agroup__geometry_html_structb2_polygon"><div class="ttname"><a href="group__geometry.html#structb2_polygon">b2Polygon</a></div><div class="ttdoc">A solid convex polygon.</div><div class="ttdef"><b>Definition</b> collision.h:134</div></div>
<div class="ttc" id="agroup__shape_html_a965b7e4e4aafb33383ece1c9febb6c3b"><div class="ttname"><a href="group__shape.html#a965b7e4e4aafb33383ece1c9febb6c3b">b2ShapeDef::material</a></div><div class="ttdeci">b2SurfaceMaterial material</div><div class="ttdoc">The surface material for this shape.</div><div class="ttdef"><b>Definition</b> types.h:373</div></div>
<div class="ttc" id="agroup__shape_html_ab0ddf90317622a46ac9cb54e47342b54"><div class="ttname"><a href="group__shape.html#ab0ddf90317622a46ac9cb54e47342b54">b2ShapeDef::density</a></div><div class="ttdeci">float density</div><div class="ttdoc">The density, usually in kg/m^2.</div><div class="ttdef"><b>Definition</b> types.h:378</div></div>
<div class="ttc" id="agroup__shape_html_af164fd9a1f40ff4bb7936a5a9b030afc"><div class="ttname"><a href="group__shape.html#af164fd9a1f40ff4bb7936a5a9b030afc">b2SurfaceMaterial::friction</a></div><div class="ttdeci">float friction</div><div class="ttdoc">The Coulomb (dry) friction coefficient, usually in the range [0,1].</div><div class="ttdef"><b>Definition</b> types.h:338</div></div>
<div class="ttc" id="agroup__shape_html_ga3e55037d832f0cbf30f467eea5c6107e"><div class="ttname"><a href="group__shape.html#ga3e55037d832f0cbf30f467eea5c6107e">b2CreatePolygonShape</a></div><div class="ttdeci">B2_API b2ShapeId b2CreatePolygonShape(b2BodyId bodyId, const b2ShapeDef *def, const b2Polygon *polygon)</div><div class="ttdoc">Create a polygon shape and attach it to a body.</div></div>
<div class="ttc" id="agroup__shape_html_gab4ca752f5de1d27c953f3520bd8fcef1"><div class="ttname"><a href="group__shape.html#gab4ca752f5de1d27c953f3520bd8fcef1">b2DefaultShapeDef</a></div><div class="ttdeci">b2ShapeDef b2DefaultShapeDef(void)</div><div class="ttdoc">Use this to initialize your shape definition.</div></div>
<div class="ttc" id="agroup__shape_html_structb2_shape_def"><div class="ttname"><a href="group__shape.html#structb2_shape_def">b2ShapeDef</a></div><div class="ttdoc">Used to create a shape.</div><div class="ttdef"><b>Definition</b> types.h:368</div></div>
</div><!-- fragment --><p>This creates a polygon and attaches it to the body. You do not need to store the shape id since the shape will automatically be destroyed when the parent body is destroyed. However, you may wish to store the shape id if you plan to change properties on it later.</p>
<p>You can create multiple shapes on a single body. They all can contribute to the mass of the body. These shapes never collide with each other and may overlap.</p>
<p>You can destroy a shape on the parent body. You may do this to model a breakable object. Otherwise you can just leave the shape alone and let the body destruction take care of destroying the attached shapes.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__shape.html#gab34430e8941b244ed8ffcc7d8dc3e249">b2DestroyShape</a>(myShapeId);</div>
<div class="ttc" id="agroup__shape_html_gab34430e8941b244ed8ffcc7d8dc3e249"><div class="ttname"><a href="group__shape.html#gab34430e8941b244ed8ffcc7d8dc3e249">b2DestroyShape</a></div><div class="ttdeci">B2_API void b2DestroyShape(b2ShapeId shapeId, bool updateBodyMass)</div><div class="ttdoc">Destroy a shape.</div></div>
</div><!-- fragment --><p>Material properties such as density, friction, and restitution are associated with shapes instead of bodies. Since you can attach multiple shapes to a body, this allows for more possible setups. For example, you can make a car that is heavier in the back.</p>
<h2><a class="anchor" id="autotoc_md76"></a>
Density</h2>
<p>The shape density is used to compute the mass properties of the parent body. The density can be zero or positive. You should generally use similar densities for all your shapes. This will improve stacking stability.</p>
<p>The mass of a body is not adjusted when you set the density. You must call <code><a class="el" href="group__body.html#ga4b13599263b8f51ddba9a89c30c6fd0c" title="This update the mass properties to the sum of the mass properties of the shapes.">b2Body_ApplyMassFromShapes()</a></code> for this to occur. Generally you should establish the shape density in <code><a class="el" href="group__shape.html#structb2_shape_def" title="Used to create a shape.">b2ShapeDef</a></code> and avoid modifying it later because this can be expensive, especially on a compound body.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__shape.html#ga15fbd57e50b422fe3e750533a91af210">b2Shape_SetDensity</a>(myShapeId, 5.0f);</div>
<div class="line"><a class="code hl_function" href="group__body.html#ga4b13599263b8f51ddba9a89c30c6fd0c">b2Body_ApplyMassFromShapes</a>(myBodyId);</div>
<div class="ttc" id="agroup__shape_html_ga15fbd57e50b422fe3e750533a91af210"><div class="ttname"><a href="group__shape.html#ga15fbd57e50b422fe3e750533a91af210">b2Shape_SetDensity</a></div><div class="ttdeci">B2_API void b2Shape_SetDensity(b2ShapeId shapeId, float density, bool updateBodyMass)</div><div class="ttdoc">Set the mass density of a shape, usually in kg/m^2.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md77"></a>
Friction</h2>
<p>Friction is used to make objects slide along each other realistically. Box2D supports static and dynamic friction, but uses the same parameter for both. Box2D attempts to simulate friction accurately and the friction strength is proportional to the normal force. This is called <a href="https://en.wikipedia.org/wiki/Friction">Coulomb friction</a>. The friction parameter is usually set between 0 and 1, but can be any non-negative value. A friction value of 0 turns off friction and a value of 1 makes the friction strong. When the friction force is computed between two shapes, Box2D must combine the friction parameters of the two parent shapes. This is done with the <a href="https://en.wikipedia.org/wiki/Geometric_mean">geometric mean</a>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> mixedFriction = sqrtf(<a class="code hl_function" href="group__shape.html#ga0dd13c39b24145212f669311d467ac1d">b2Shape_GetFriction</a>(shapeIdA) * <a class="code hl_function" href="group__shape.html#ga0dd13c39b24145212f669311d467ac1d">b2Shape_GetFriction</a>(shapeIdB));</div>
<div class="ttc" id="agroup__shape_html_ga0dd13c39b24145212f669311d467ac1d"><div class="ttname"><a href="group__shape.html#ga0dd13c39b24145212f669311d467ac1d">b2Shape_GetFriction</a></div><div class="ttdeci">B2_API float b2Shape_GetFriction(b2ShapeId shapeId)</div><div class="ttdoc">Get the friction of a shape.</div></div>
</div><!-- fragment --><p>If one shape has zero friction then the mixed friction will be zero.</p>
<h2><a class="anchor" id="autotoc_md78"></a>
Restitution</h2>
<p><a href="https://en.wikipedia.org/wiki/Coefficient_of_restitution">Restitution</a> is used to make objects bounce. The restitution value is usually set to be between 0 and 1. Consider dropping a ball on a table. A value of zero means the ball won't bounce. This is called an <em>inelastic</em> collision. A value of one means the ball's velocity will be exactly reflected. This is called a <em>perfectly elastic</em> collision. Restitution is combined using the following formula.</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> mixedRestitution = <a class="code hl_function" href="group__math.html#ga8444272da41b94e7a11ac969b15ecdaa">b2MaxFloat</a>(<a class="code hl_function" href="group__shape.html#ga83ea5ba178582bc49aade1fd82db1c0a">b2Shape_GetRestitution</a>(shapeIdA), <a class="code hl_function" href="group__shape.html#ga83ea5ba178582bc49aade1fd82db1c0a">b2Shape_GetRestitution</a>(shapeIdB));</div>
<div class="ttc" id="agroup__math_html_ga8444272da41b94e7a11ac969b15ecdaa"><div class="ttname"><a href="group__math.html#ga8444272da41b94e7a11ac969b15ecdaa">b2MaxFloat</a></div><div class="ttdeci">float b2MaxFloat(float a, float b)</div><div class="ttdef"><b>Definition</b> math_functions.h:117</div></div>
<div class="ttc" id="agroup__shape_html_ga83ea5ba178582bc49aade1fd82db1c0a"><div class="ttname"><a href="group__shape.html#ga83ea5ba178582bc49aade1fd82db1c0a">b2Shape_GetRestitution</a></div><div class="ttdeci">B2_API float b2Shape_GetRestitution(b2ShapeId shapeId)</div><div class="ttdoc">Get the shape restitution.</div></div>
</div><!-- fragment --><p>Restitution is combined this way so that you can have a bouncy super ball without having a bouncy floor.</p>
<p>When a shape develops multiple contacts, restitution is simulated approximately. This is because Box2D uses a sequential solver. Box2D also uses inelastic collisions when the collision velocity is small. This is done to prevent jitter. See <code><a class="el" href="group__world.html#aac6834c8e6e29c0aba4ecaff28cf8195" title="Restitution speed threshold, usually in m/s.">b2WorldDef::restitutionThreshold</a></code>.</p>
<h2><a class="anchor" id="autotoc_md79"></a>
Friction and restitution callbacks</h2>
<p>Advanced users can override friction and restitution mixing using <a class="el" href="group__world.html#ga114d2df5b60d1636ca2b4a1cb0227e60" title="Optional friction mixing callback.">b2FrictionCallback</a> and <a class="el" href="group__world.html#ga35de4bebe2d28193d77a01ff02dd7e88" title="Optional restitution mixing callback.">b2RestitutionCallback</a>. These should be very light weight functions because they are called frequently. See the API reference for details.</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> MyFrictionCallback(<span class="keywordtype">float</span> frictionA, <span class="keywordtype">int</span> userMaterialIdA, <span class="keywordtype">float</span> frictionB, <span class="keywordtype">int</span> userMaterialIdB)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (userMaterialIdA &gt; userMaterialIdB)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> frictionA;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> frictionB;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="group__world.html#structb2_world_def">b2WorldDef</a> worldDef = <a class="code hl_function" href="group__world.html#gaf2777d7b8c7f2f289d5b70b3da9bd75f">b2DefaultWorldDef</a>();</div>
<div class="line">worldDef.<a class="code hl_variable" href="group__world.html#a27033a6f1f105d78f9f9a9736a31f636">frictionCallback</a> = MyFrictionCallback;</div>
<div class="ttc" id="agroup__world_html_a27033a6f1f105d78f9f9a9736a31f636"><div class="ttname"><a href="group__world.html#a27033a6f1f105d78f9f9a9736a31f636">b2WorldDef::frictionCallback</a></div><div class="ttdeci">b2FrictionCallback * frictionCallback</div><div class="ttdoc">Optional mixing callback for friction. The default uses sqrt(frictionA * frictionB).</div><div class="ttdef"><b>Definition</b> types.h:114</div></div>
</div><!-- fragment --><h2><a class="anchor" id="filtering"></a>
Filtering</h2>
<p>Collision filtering allows you to efficiently prevent collision between shapes. For example, say you make a character that rides a bicycle. You want the bicycle to collide with the terrain and the character to collide with the terrain, but you don't want the character to collide with the bicycle (because they must overlap). Box2D supports such collision filtering using categories, masks, and groups.</p>
<p>Box2D supports 64 collision categories. For each shape you can specify which category it belongs to. You can also specify what other categories this shape can collide with. For example, you could specify in a multiplayer game that players don't collide with each other. Rather than identifying all the situations where things should not collide, I recommend identifying all the situations where things should collide. This way you don't get into situations where you are using <a href="https://en.wikipedia.org/wiki/Double_negative">double negatives</a>. You can specify which things can collide using mask bits. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> MyCategories</div>
<div class="line">{</div>
<div class="line">    PLAYER = 0x00000002,</div>
<div class="line">    MONSTER = 0x00000004,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="group__shape.html#structb2_shape_def">b2ShapeDef</a> playerShapeDef = <a class="code hl_function" href="group__shape.html#gab4ca752f5de1d27c953f3520bd8fcef1">b2DefaultShapeDef</a>();</div>
<div class="line"><a class="code hl_struct" href="group__shape.html#structb2_shape_def">b2ShapeDef</a> monsterShapeDef = <a class="code hl_function" href="group__shape.html#gab4ca752f5de1d27c953f3520bd8fcef1">b2DefaultShapeDef</a>();</div>
<div class="line">playerShapeDef.<a class="code hl_variable" href="group__shape.html#ab016578b0f00040c8f952aaa92e8ab2f">filter</a>.<a class="code hl_variable" href="group__shape.html#aa93b718a9aecd5c5c9a05708860c8f2c">categoryBits</a> = PLAYER;</div>
<div class="line">monsterShapeDef.<a class="code hl_variable" href="group__shape.html#ab016578b0f00040c8f952aaa92e8ab2f">filter</a>.<a class="code hl_variable" href="group__shape.html#aa93b718a9aecd5c5c9a05708860c8f2c">categoryBits</a> = MONSTER;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Players collide with monsters, but not with other players</span></div>
<div class="line">playerShapeDef.<a class="code hl_variable" href="group__shape.html#ab016578b0f00040c8f952aaa92e8ab2f">filter</a>.<a class="code hl_variable" href="group__shape.html#a77f175cd1413952cc26c866cebdee259">maskBits</a> = MONSTER;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Monsters collide with players and other monsters</span></div>
<div class="line">monsterShapeDef.<a class="code hl_variable" href="group__shape.html#ab016578b0f00040c8f952aaa92e8ab2f">filter</a>.<a class="code hl_variable" href="group__shape.html#a77f175cd1413952cc26c866cebdee259">maskBits</a> = PLAYER | MONSTER;</div>
<div class="ttc" id="agroup__shape_html_a77f175cd1413952cc26c866cebdee259"><div class="ttname"><a href="group__shape.html#a77f175cd1413952cc26c866cebdee259">b2Filter::maskBits</a></div><div class="ttdeci">uint64_t maskBits</div><div class="ttdoc">The collision mask bits.</div><div class="ttdef"><b>Definition</b> types.h:277</div></div>
<div class="ttc" id="agroup__shape_html_aa93b718a9aecd5c5c9a05708860c8f2c"><div class="ttname"><a href="group__shape.html#aa93b718a9aecd5c5c9a05708860c8f2c">b2Filter::categoryBits</a></div><div class="ttdeci">uint64_t categoryBits</div><div class="ttdoc">The collision category bits.</div><div class="ttdef"><b>Definition</b> types.h:268</div></div>
<div class="ttc" id="agroup__shape_html_ab016578b0f00040c8f952aaa92e8ab2f"><div class="ttname"><a href="group__shape.html#ab016578b0f00040c8f952aaa92e8ab2f">b2ShapeDef::filter</a></div><div class="ttdeci">b2Filter filter</div><div class="ttdoc">Collision filtering data.</div><div class="ttdef"><b>Definition</b> types.h:381</div></div>
</div><!-- fragment --><p>Here is the rule for a collision to occur:</p>
<div class="fragment"><div class="line">uint64_t catA = shapeA.filter.categoryBits;</div>
<div class="line">uint64_t maskA = shapeA.filter.maskBits;</div>
<div class="line">uint64_t catB = shapeB.filter.categoryBits;</div>
<div class="line">uint64_t maskB = shapeB.filter.maskBits;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> ((catA &amp; maskB) != 0 &amp;&amp; (catB &amp; maskA) != 0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// shapes can collide</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Another filtering feature is <em>collision group</em>. Collision groups let you specify a group index. You can have all shapes with the same group index always collide (positive index) or never collide (negative index). Group indices are usually used for things that are somehow related, like the parts of a bicycle. In the following example, shape1 and shape2 always collide, but shape3 and shape4 never collide.</p>
<div class="fragment"><div class="line">shape1Def.filter.groupIndex = 2;</div>
<div class="line">shape2Def.filter.groupIndex = 2;</div>
<div class="line">shape3Def.filter.groupIndex = -8;</div>
<div class="line">shape4Def.filter.groupIndex = -8;</div>
</div><!-- fragment --><p>Collisions between shapes of different group indices are filtered according the category and mask bits. If two shapes have the same non-zero group index, then this overrides the category and mask. Collision groups have a higher priority than categories and masks.</p>
<p>Note that additional collision filtering occurs automatically in Box2D. Here is a list:</p><ul>
<li>A shape on a static body can only collide with a dynamic body.</li>
<li>A shape on a kinematic body can only collide with a dynamic body.</li>
<li>Shapes on the same body never collide with each other.</li>
<li>You can optionally enable/disable collision between bodies connected by a joint.</li>
</ul>
<p>Sometimes you might need to change collision filtering after a shape has already been created. You can get and set the <code><a class="el" href="group__shape.html#structb2_filter" title="This is used to filter collision on shapes.">b2Filter</a></code> structure on an existing shape using <code><a class="el" href="group__shape.html#gac115a5cab16b5f3dd422b4e8ba35e25f" title="Get the shape filter.">b2Shape_GetFilter()</a></code> and <code><a class="el" href="group__shape.html#ga7ed6b1bf54d7855e35b1950b08d447af" title="Set the current filter.">b2Shape_SetFilter()</a></code>. Changing the filter is expensive because it causes contacts to be destroyed.</p>
<h2><a class="anchor" id="autotoc_md80"></a>
Chain Shapes</h2>
<p>The chain shape provides an efficient way to connect many line segments together to construct your static game worlds. Chain shapes automatically eliminate ghost collisions and provide one-sided collision.</p>
<p>If you don't care about ghost collisions, you can create a bunch of two-sided segment shapes. The performance is similar.</p>
<p>The simplest way to use chain shapes is to create loops. Simply provide an array of vertices.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> points[4] = {</div>
<div class="line">    {1.7f, 0.0f},</div>
<div class="line">    {1.0f, 0.25f},</div>
<div class="line">    {0.0f, 0.0f},</div>
<div class="line">    {-1.7f, 0.4f}};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="group__shape.html#structb2_chain_def">b2ChainDef</a> chainDef = <a class="code hl_function" href="group__shape.html#ga47bbb3d14c028cc57e1c32da92f51d44">b2DefaultChainDef</a>();</div>
<div class="line">chainDef.<a class="code hl_variable" href="group__shape.html#a828c614397c024606159528381be07f6">points</a> = points;</div>
<div class="line">chainDef.<a class="code hl_variable" href="group__shape.html#a5426ba095d894ee2a918adeeb7c8832a">count</a> = 4;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="group__id.html#structb2_chain_id">b2ChainId</a> myChainId = <a class="code hl_function" href="group__shape.html#ga65c9fc614cba7f5fbd13a7e54c192b7b">b2CreateChain</a>(myBodyId, &amp;chainDef);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Later ...</span></div>
<div class="line"><a class="code hl_function" href="group__shape.html#gaa2e3bce8dd9e9cbe65b2043d04e6866c">b2DestroyChain</a>(myChainId);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Nullify id for safety</span></div>
<div class="line">myChainId = b2_nullChainId;</div>
<div class="ttc" id="agroup__id_html_structb2_chain_id"><div class="ttname"><a href="group__id.html#structb2_chain_id">b2ChainId</a></div><div class="ttdoc">Chain id references a chain instances. This should be treated as an opaque handle.</div><div class="ttdef"><b>Definition</b> id.h:61</div></div>
<div class="ttc" id="agroup__shape_html_a5426ba095d894ee2a918adeeb7c8832a"><div class="ttname"><a href="group__shape.html#a5426ba095d894ee2a918adeeb7c8832a">b2ChainDef::count</a></div><div class="ttdeci">int count</div><div class="ttdoc">The point count, must be 4 or more.</div><div class="ttdef"><b>Definition</b> types.h:443</div></div>
<div class="ttc" id="agroup__shape_html_a828c614397c024606159528381be07f6"><div class="ttname"><a href="group__shape.html#a828c614397c024606159528381be07f6">b2ChainDef::points</a></div><div class="ttdeci">const b2Vec2 * points</div><div class="ttdoc">An array of at least 4 points. These are cloned and may be temporary.</div><div class="ttdef"><b>Definition</b> types.h:440</div></div>
<div class="ttc" id="agroup__shape_html_ga47bbb3d14c028cc57e1c32da92f51d44"><div class="ttname"><a href="group__shape.html#ga47bbb3d14c028cc57e1c32da92f51d44">b2DefaultChainDef</a></div><div class="ttdeci">b2ChainDef b2DefaultChainDef(void)</div><div class="ttdoc">Use this to initialize your chain definition.</div></div>
<div class="ttc" id="agroup__shape_html_ga65c9fc614cba7f5fbd13a7e54c192b7b"><div class="ttname"><a href="group__shape.html#ga65c9fc614cba7f5fbd13a7e54c192b7b">b2CreateChain</a></div><div class="ttdeci">B2_API b2ChainId b2CreateChain(b2BodyId bodyId, const b2ChainDef *def)</div><div class="ttdoc">Chain Shape.</div></div>
<div class="ttc" id="agroup__shape_html_gaa2e3bce8dd9e9cbe65b2043d04e6866c"><div class="ttname"><a href="group__shape.html#gaa2e3bce8dd9e9cbe65b2043d04e6866c">b2DestroyChain</a></div><div class="ttdeci">B2_API void b2DestroyChain(b2ChainId chainId)</div><div class="ttdoc">Destroy a chain shape.</div></div>
<div class="ttc" id="agroup__shape_html_structb2_chain_def"><div class="ttname"><a href="group__shape.html#structb2_chain_def">b2ChainDef</a></div><div class="ttdoc">Used to create a chain of line segments.</div><div class="ttdef"><b>Definition</b> types.h:435</div></div>
</div><!-- fragment --><p>The segment normal depends on the winding order. A counter-clockwise winding order orients the normal outwards and a clockwise winding order orients the normal inwards.</p>
<div class="image">
<object type="image/svg+xml" data="chain_loop_outwards.svg" style="pointer-events: none;"></object>
<div class="caption">
Chain Shape Outwards Loop</div></div>
    <div class="image">
<object type="image/svg+xml" data="chain_loop_inwards.svg" style="pointer-events: none;"></object>
<div class="caption">
Chain Shape Inwards Loop</div></div>
    <p>You may have a scrolling game world and would like to connect several chains together. You can connect chains together using ghost vertices. To do this you must have the first three or last three points of each chain overlap. See the sample <code>ChainLink</code> for details.</p>
<div class="image">
<object type="image/svg+xml" data="chain_shape.svg" style="pointer-events: none;"></object>
<div class="caption">
Chain Shape</div></div>
    <p>Self-intersection of chain shapes is not supported. It might work, it might not. The code that prevents ghost collisions assumes there are no self-intersections of the chain. Also, very close vertices can cause problems. Make sure all your points are more than than about a centimeter apart.</p>
<div class="image">
<object type="image/svg+xml" data="self_intersect.svg" style="pointer-events: none;"></object>
<div class="caption">
Self Intersection is Bad</div></div>
    <p>Each segment in the chain is created as a <code><a class="el" href="group__geometry.html#structb2_chain_segment" title="A line segment with one-sided collision.">b2ChainSegment</a></code> shape on the body. If you have the shape id for a chain segment shape, you can get the owning chain id. This will return <code>b2_nullChainId</code> if the shape is not a chain segment.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__id.html#structb2_chain_id">b2ChainId</a> chainId = b2SHape_GetParentChain(myShapeId);</div>
</div><!-- fragment --><p>You cannot create a chain segment shape directly.</p>
<h2><a class="anchor" id="autotoc_md81"></a>
Sensors</h2>
<p>Sometimes game logic needs to know when two shapes overlap yet there should be no collision response. This is done by using sensors. A sensor is a shape that detects overlap but does not produce a response.</p>
<p>You can flag any shape as being a sensor. Sensors may be static, kinematic, or dynamic. Remember that you may have multiple shapes per body and you can have any mix of sensors and solid shapes. Sensors can also detect other sensors.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__shape.html#structb2_shape_def">b2ShapeDef</a> shapeDef = <a class="code hl_function" href="group__shape.html#gab4ca752f5de1d27c953f3520bd8fcef1">b2DefaultShapeDef</a>();</div>
<div class="line">shapeDef.<a class="code hl_variable" href="group__shape.html#a6851ac8355eedfff014f926015d29ff0">isSensor</a> = <span class="keyword">true</span>;</div>
<div class="ttc" id="agroup__shape_html_a6851ac8355eedfff014f926015d29ff0"><div class="ttname"><a href="group__shape.html#a6851ac8355eedfff014f926015d29ff0">b2ShapeDef::isSensor</a></div><div class="ttdeci">bool isSensor</div><div class="ttdoc">A sensor shape generates overlap events but never generates a collision response.</div><div class="ttdef"><b>Definition</b> types.h:388</div></div>
</div><!-- fragment --><p>For both sensors and non-sensors, sensor events must also be enabled. There is a performance cost to generate sensor events, so they are disabled by default.</p>
<div class="fragment"><div class="line">shapeDef.<a class="code hl_variable" href="group__shape.html#adf048879e1f6c0226fe5db754acdb350">enableSensorEvents</a> = <span class="keyword">true</span>;</div>
<div class="ttc" id="agroup__shape_html_adf048879e1f6c0226fe5db754acdb350"><div class="ttname"><a href="group__shape.html#adf048879e1f6c0226fe5db754acdb350">b2ShapeDef::enableSensorEvents</a></div><div class="ttdeci">bool enableSensorEvents</div><div class="ttdoc">Enable sensor events for this shape. This applies to sensors and non-sensors. False by default,...</div><div class="ttdef"><b>Definition</b> types.h:391</div></div>
</div><!-- fragment --><p>Sensors are processed at the end of the world step and generate begin and end events without delay. User operations may cause overlaps to begin or end. These are processed the next time step. Such operations include:</p><ul>
<li>destroying a body or shape</li>
<li>changing a shape filter</li>
<li>disabling or enabling a body</li>
<li>setting a body transform</li>
<li>disabling or enabling sensor events on a shape</li>
</ul>
<p>Sensors do not detect objects that pass through the sensor shape within one time step. So sensors do not have continuous collision detection. If you have fast moving object and/or small sensors then you should use a ray or shape cast to detect these events.</p>
<p>You can access the current sensor overlaps. Be careful because some shape ids may be invalid due to a shape being destroyed. Use <code>b2Shape_IsValid</code> to ensure an overlapping shape is still valid.</p>
<div class="fragment"><div class="line"><span class="comment">// First determine the required array capacity to hold all the overlapping shape ids.</span></div>
<div class="line"><span class="keywordtype">int</span> capacity = <a class="code hl_function" href="group__shape.html#ga6684d05323427be7b5825f74c3737604">b2Shape_GetSensorCapacity</a>( sensorShapeId );</div>
<div class="line">std::vector&lt;b2ShapeId&gt; overlaps;</div>
<div class="line">overlaps.resize( capacity );</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Now get all overlaps and record the actual count</span></div>
<div class="line"><span class="keywordtype">int</span> count = <a class="code hl_function" href="group__shape.html#ga29630bb7ae846149a8a143fe03c9cea3">b2Shape_GetSensorOverlaps</a>( sensorShapeId, overlaps.data(), capacity );</div>
<div class="line">overlaps.resize( count );</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; count; ++i )</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="group__id.html#structb2_shape_id">b2ShapeId</a> visitorId = overlaps[i];</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Ensure the visitorId is valid</span></div>
<div class="line">    <span class="keywordflow">if</span> ( <a class="code hl_function" href="group__shape.html#ga48f3b596f9ae950c7b3c752528808476">b2Shape_IsValid</a>( visitorId ) == <span class="keyword">false</span> )</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">continue</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// process overlap using game logic</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__shape_html_ga29630bb7ae846149a8a143fe03c9cea3"><div class="ttname"><a href="group__shape.html#ga29630bb7ae846149a8a143fe03c9cea3">b2Shape_GetSensorOverlaps</a></div><div class="ttdeci">B2_API int b2Shape_GetSensorOverlaps(b2ShapeId shapeId, b2ShapeId *overlaps, int capacity)</div><div class="ttdoc">Get the overlapped shapes for a sensor shape.</div></div>
<div class="ttc" id="agroup__shape_html_ga48f3b596f9ae950c7b3c752528808476"><div class="ttname"><a href="group__shape.html#ga48f3b596f9ae950c7b3c752528808476">b2Shape_IsValid</a></div><div class="ttdeci">B2_API bool b2Shape_IsValid(b2ShapeId id)</div><div class="ttdoc">Shape identifier validation. Provides validation for up to 64K allocations.</div></div>
<div class="ttc" id="agroup__shape_html_ga6684d05323427be7b5825f74c3737604"><div class="ttname"><a href="group__shape.html#ga6684d05323427be7b5825f74c3737604">b2Shape_GetSensorCapacity</a></div><div class="ttdeci">B2_API int b2Shape_GetSensorCapacity(b2ShapeId shapeId)</div><div class="ttdoc">Get the maximum capacity required for retrieving all the overlapped shapes on a sensor shape.</div></div>
</div><!-- fragment --><p>Sensor overlap can also be determined using events, which are described below.</p>
<h2><a class="anchor" id="autotoc_md82"></a>
Sensor Events</h2>
<p>Sensor events are available after every call to <code><a class="el" href="group__world.html#ga8441b35f0a5d67ccf40961a94d4941ef" title="Simulate a world for one time step.">b2World_Step()</a></code>. Sensor events are the best way to get information about sensors overlaps. There are events for when a shape begins to overlap with a sensor.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__events.html#structb2_sensor_events">b2SensorEvents</a> sensorEvents = <a class="code hl_function" href="group__world.html#ga68fddcb791a44f230d63be2d1412e930">b2World_GetSensorEvents</a>(myWorldId);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; sensorEvents.<a class="code hl_variable" href="group__events.html#a231c96704fd32adfce53304b2a9d2938">beginCount</a>; ++i)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="group__events.html#structb2_sensor_begin_touch_event">b2SensorBeginTouchEvent</a>* beginTouch = sensorEvents.<a class="code hl_variable" href="group__events.html#afd4114633b97ac67987389a075cef877">beginEvents</a> + i;</div>
<div class="line">    <span class="keywordtype">void</span>* myUserData = <a class="code hl_function" href="group__shape.html#ga5e736a82754b5e9799fa9cf7a751bfd3">b2Shape_GetUserData</a>(beginTouch-&gt;<a class="code hl_variable" href="group__events.html#af698b66e2b4a1a7514376ea311ab9a66">visitorShapeId</a>);</div>
<div class="line">    <span class="comment">// process begin event</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__events_html_a231c96704fd32adfce53304b2a9d2938"><div class="ttname"><a href="group__events.html#a231c96704fd32adfce53304b2a9d2938">b2SensorEvents::beginCount</a></div><div class="ttdeci">int beginCount</div><div class="ttdoc">The number of begin touch events.</div><div class="ttdef"><b>Definition</b> types.h:1040</div></div>
<div class="ttc" id="agroup__events_html_af698b66e2b4a1a7514376ea311ab9a66"><div class="ttname"><a href="group__events.html#af698b66e2b4a1a7514376ea311ab9a66">b2SensorBeginTouchEvent::visitorShapeId</a></div><div class="ttdeci">b2ShapeId visitorShapeId</div><div class="ttdoc">The id of the dynamic shape that began touching the sensor shape.</div><div class="ttdef"><b>Definition</b> types.h:1007</div></div>
<div class="ttc" id="agroup__events_html_afd4114633b97ac67987389a075cef877"><div class="ttname"><a href="group__events.html#afd4114633b97ac67987389a075cef877">b2SensorEvents::beginEvents</a></div><div class="ttdeci">b2SensorBeginTouchEvent * beginEvents</div><div class="ttdoc">Array of sensor begin touch events.</div><div class="ttdef"><b>Definition</b> types.h:1034</div></div>
<div class="ttc" id="agroup__events_html_structb2_sensor_begin_touch_event"><div class="ttname"><a href="group__events.html#structb2_sensor_begin_touch_event">b2SensorBeginTouchEvent</a></div><div class="ttdoc">A begin touch event is generated when a shape starts to overlap a sensor shape.</div><div class="ttdef"><b>Definition</b> types.h:1002</div></div>
<div class="ttc" id="agroup__events_html_structb2_sensor_events"><div class="ttname"><a href="group__events.html#structb2_sensor_events">b2SensorEvents</a></div><div class="ttdoc">Sensor events are buffered in the Box2D world and are available as begin/end overlap event arrays aft...</div><div class="ttdef"><b>Definition</b> types.h:1032</div></div>
<div class="ttc" id="agroup__shape_html_ga5e736a82754b5e9799fa9cf7a751bfd3"><div class="ttname"><a href="group__shape.html#ga5e736a82754b5e9799fa9cf7a751bfd3">b2Shape_GetUserData</a></div><div class="ttdeci">B2_API void * b2Shape_GetUserData(b2ShapeId shapeId)</div><div class="ttdoc">Get the user data for a shape.</div></div>
<div class="ttc" id="agroup__world_html_ga68fddcb791a44f230d63be2d1412e930"><div class="ttname"><a href="group__world.html#ga68fddcb791a44f230d63be2d1412e930">b2World_GetSensorEvents</a></div><div class="ttdeci">B2_API b2SensorEvents b2World_GetSensorEvents(b2WorldId worldId)</div><div class="ttdoc">Get sensor events for the current time step. The event data is transient. Do not store a reference to...</div></div>
</div><!-- fragment --><p>And there are events when a shape stops overlapping with a sensor. Be careful with end touch events because they may be generated when shapes are destroyed. Test the shape ids with <code>b2Shape_IsValid</code>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; sensorEvents.<a class="code hl_variable" href="group__events.html#adb0540645736411964c83ea36a18478e">endCount</a>; ++i)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="group__events.html#structb2_sensor_end_touch_event">b2SensorEndTouchEvent</a>* endTouch = sensorEvents.<a class="code hl_variable" href="group__events.html#a9ed62cce14b95bce293069134979de28">endEvents</a> + i;</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="group__shape.html#ga48f3b596f9ae950c7b3c752528808476">b2Shape_IsValid</a>(endTouch-&gt;<a class="code hl_variable" href="group__events.html#ac9141778f6331246ee9ea2248694ae3b">visitorShapeId</a>))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">void</span>* myUserData = <a class="code hl_function" href="group__shape.html#ga5e736a82754b5e9799fa9cf7a751bfd3">b2Shape_GetUserData</a>(endTouch-&gt;<a class="code hl_variable" href="group__events.html#ac9141778f6331246ee9ea2248694ae3b">visitorShapeId</a>);</div>
<div class="line">        <span class="comment">// process end event</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__events_html_a9ed62cce14b95bce293069134979de28"><div class="ttname"><a href="group__events.html#a9ed62cce14b95bce293069134979de28">b2SensorEvents::endEvents</a></div><div class="ttdeci">b2SensorEndTouchEvent * endEvents</div><div class="ttdoc">Array of sensor end touch events.</div><div class="ttdef"><b>Definition</b> types.h:1037</div></div>
<div class="ttc" id="agroup__events_html_ac9141778f6331246ee9ea2248694ae3b"><div class="ttname"><a href="group__events.html#ac9141778f6331246ee9ea2248694ae3b">b2SensorEndTouchEvent::visitorShapeId</a></div><div class="ttdeci">b2ShapeId visitorShapeId</div><div class="ttdoc">The id of the dynamic shape that stopped touching the sensor shape.</div><div class="ttdef"><b>Definition</b> types.h:1024</div></div>
<div class="ttc" id="agroup__events_html_adb0540645736411964c83ea36a18478e"><div class="ttname"><a href="group__events.html#adb0540645736411964c83ea36a18478e">b2SensorEvents::endCount</a></div><div class="ttdeci">int endCount</div><div class="ttdoc">The number of end touch events.</div><div class="ttdef"><b>Definition</b> types.h:1043</div></div>
<div class="ttc" id="agroup__events_html_structb2_sensor_end_touch_event"><div class="ttname"><a href="group__events.html#structb2_sensor_end_touch_event">b2SensorEndTouchEvent</a></div><div class="ttdoc">An end touch event is generated when a shape stops overlapping a sensor shape.</div><div class="ttdef"><b>Definition</b> types.h:1015</div></div>
</div><!-- fragment --><p>Sensor events should be processed after the world step and before other game logic. This should help you avoid processing stale data.</p>
<p>Sensor events are only enabled for shapes and sensors if <a class="el" href="group__shape.html#adf048879e1f6c0226fe5db754acdb350" title="Enable sensor events for this shape. This applies to sensors and non-sensors. False by default,...">b2ShapeDef::enableSensorEvents</a> is set to true.</p>
<blockquote class="doxtable">
<p><b>Note</b>: A shape cannot start or stop being a sensor. Such a feature would break sensor events, potentially causing bugs in game logic. </p>
</blockquote>
<h1><a class="anchor" id="autotoc_md83"></a>
Contacts</h1>
<p>Contacts are internal objects created by Box2D to manage collision between pairs of shapes. They are fundamental to rigid body simulation in games.</p>
<h2><a class="anchor" id="autotoc_md84"></a>
Terminology</h2>
<p>Contacts have a fair bit of terminology that are important to review.</p>
<h3><a class="anchor" id="autotoc_md85"></a>
contact point</h3>
<p>A contact point is a point where two shapes touch. Box2D approximates contact with a small number of points. Specifically, contact between two shapes has 0, 1, or 2 points. This is possible because Box2D uses convex shapes.</p>
<h3><a class="anchor" id="autotoc_md86"></a>
contact normal</h3>
<p>A contact normal is a unit vector that points from one shape to another. By convention, the normal points from shapeA to shapeB.</p>
<h3><a class="anchor" id="autotoc_md87"></a>
contact separation</h3>
<p>Separation is the opposite of penetration. Separation is negative when shapes overlap.</p>
<h3><a class="anchor" id="autotoc_md88"></a>
contact manifold</h3>
<p>Contact between two convex polygons may generate up to 2 contact points. Both of these points use the same normal, so they are grouped into a contact manifold, which is an approximation of a continuous region of contact.</p>
<h3><a class="anchor" id="autotoc_md89"></a>
normal impulse</h3>
<p>The normal force is the force applied at a contact point to prevent the shapes from penetrating. For convenience, Box2D uses impulses. The normal impulse is just the normal force multiplied by the time step. Since Box2D uses sub-stepping, this is the sub-step time step.</p>
<h3><a class="anchor" id="autotoc_md90"></a>
tangent impulse</h3>
<p>The tangent force is generated at a contact point to simulate friction. For convenience, this is stored as an impulse.</p>
<h3><a class="anchor" id="autotoc_md91"></a>
contact point id</h3>
<p>Box2D tries to re-use the contact impulse results from a time step as the initial guess for the next time step. Box2D uses contact point ids to match contact points across time steps. The ids contain geometric feature indices that help to distinguish one contact point from another.</p>
<h3><a class="anchor" id="autotoc_md92"></a>
speculative contact</h3>
<p>When two shapes are close together, Box2D will create up to two contact points even if the shapes are not touching. This lets Box2D anticipate collision to improve behavior. Speculative contact points have positive separation.</p>
<h2><a class="anchor" id="autotoc_md93"></a>
Contact Lifetime</h2>
<p>Contacts are created when two shape's AABBs (bounding boxes) begin to overlap. Sometimes collision filtering will prevent the creation of contacts. Contacts are destroyed with the AABBs cease to overlap.</p>
<p>So you might gather that there may be contacts created for shapes that are not touching (just their AABBs). Well, this is correct. It's a "chicken or egg" problem. We don't know if we need a contact object until one is created to analyze the collision. We could delete the contact right away if the shapes are not touching, or we can just wait until the AABBs stop overlapping. Box2D takes the latter approach because it lets the system cache information to improve performance.</p>
<h2><a class="anchor" id="autotoc_md94"></a>
Contact Data</h2>
<p>As mentioned before, the contact is created and destroyed by Box2D automatically. Contact data is not created by the user. However, you are able to access the contact data.</p>
<p>You can get contact data from shapes or bodies. The contact data on a shape is a sub-set of the contact data on a body. The contact data is only returned for touching contacts. Contacts that are not touching provide no meaningful information for an application.</p>
<p>Contact data is returned in arrays. So first you can ask a shape or body how much space you'll need in your array. This number is conservative and the actual number of contacts you'll receive may be less than this number, but never more.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> shapeContactCapacity = <a class="code hl_function" href="group__shape.html#gae8596ff9b2f4f1b14a9460d4bf79c7a6">b2Shape_GetContactCapacity</a>(myShapeId);</div>
<div class="line"><span class="keywordtype">int</span> bodyContactCapacity = <a class="code hl_function" href="group__body.html#gaf4eccf19b6a8c7a2bdf2d9c3320fa10a">b2Body_GetContactCapacity</a>(myBodyId);</div>
<div class="ttc" id="agroup__body_html_gaf4eccf19b6a8c7a2bdf2d9c3320fa10a"><div class="ttname"><a href="group__body.html#gaf4eccf19b6a8c7a2bdf2d9c3320fa10a">b2Body_GetContactCapacity</a></div><div class="ttdeci">B2_API int b2Body_GetContactCapacity(b2BodyId bodyId)</div><div class="ttdoc">Get the maximum capacity required for retrieving all the touching contacts on a body.</div></div>
<div class="ttc" id="agroup__shape_html_gae8596ff9b2f4f1b14a9460d4bf79c7a6"><div class="ttname"><a href="group__shape.html#gae8596ff9b2f4f1b14a9460d4bf79c7a6">b2Shape_GetContactCapacity</a></div><div class="ttdeci">B2_API int b2Shape_GetContactCapacity(b2ShapeId shapeId)</div><div class="ttdoc">Get the maximum capacity required for retrieving all the touching contacts on a shape.</div></div>
</div><!-- fragment --><p>You could allocate array space to get all the contact data in all cases, or you could use a fixed size array and get a limited number of results.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__events.html#structb2_contact_data">b2ContactData</a> contactData[10];</div>
<div class="line"><span class="keywordtype">int</span> shapeContactCount = <a class="code hl_function" href="group__shape.html#ga2ab82764df083ea61c24282174b9f012">b2Shape_GetContactData</a>(myShapeId, contactData, 10);</div>
<div class="line"><span class="keywordtype">int</span> bodyContactCount = <a class="code hl_function" href="group__body.html#gacdb98572a15267a3a159026c2b80ef79">b2Body_GetContactData</a>(myBodyId, contactData, 10);</div>
<div class="ttc" id="agroup__body_html_gacdb98572a15267a3a159026c2b80ef79"><div class="ttname"><a href="group__body.html#gacdb98572a15267a3a159026c2b80ef79">b2Body_GetContactData</a></div><div class="ttdeci">B2_API int b2Body_GetContactData(b2BodyId bodyId, b2ContactData *contactData, int capacity)</div><div class="ttdoc">Get the touching contact data for a body.</div></div>
<div class="ttc" id="agroup__events_html_structb2_contact_data"><div class="ttname"><a href="group__events.html#structb2_contact_data">b2ContactData</a></div><div class="ttdoc">The contact data for two shapes.</div><div class="ttdef"><b>Definition</b> types.h:1154</div></div>
<div class="ttc" id="agroup__shape_html_ga2ab82764df083ea61c24282174b9f012"><div class="ttname"><a href="group__shape.html#ga2ab82764df083ea61c24282174b9f012">b2Shape_GetContactData</a></div><div class="ttdeci">B2_API int b2Shape_GetContactData(b2ShapeId shapeId, b2ContactData *contactData, int capacity)</div><div class="ttdoc">Get the touching contact data for a shape.</div></div>
</div><!-- fragment --><p><code><a class="el" href="group__events.html#structb2_contact_data" title="The contact data for two shapes.">b2ContactData</a></code> contains the two shape ids and the manifold.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; bodyContactCount; ++i)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="group__events.html#structb2_contact_data">b2ContactData</a>* data = contactData + i;</div>
<div class="line">    printf(<span class="stringliteral">&quot;point count = %d\n&quot;</span>, data-&gt;manifold.<a class="code hl_variable" href="group__collision.html#a570b334909589d1d992c057ece371422">pointCount</a>);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__collision_html_a570b334909589d1d992c057ece371422"><div class="ttname"><a href="group__collision.html#a570b334909589d1d992c057ece371422">b2Manifold::pointCount</a></div><div class="ttdeci">int pointCount</div><div class="ttdoc">The number of contacts points, will be 0, 1, or 2.</div><div class="ttdef"><b>Definition</b> collision.h:550</div></div>
</div><!-- fragment --><p>Getting contact data off shapes and bodies is not the most efficient way to handle contact data. Instead you should use contact events.</p>
<h2><a class="anchor" id="autotoc_md95"></a>
Contact Events</h2>
<p>Contact events are available after each world step. Like sensor events these should be retrieved and processed before performing other game logic. Otherwise you may be accessing orphaned/invalid data.</p>
<p>You can access all contact events in a single data structure. This is much more efficient than using functions like <code><a class="el" href="group__body.html#gacdb98572a15267a3a159026c2b80ef79" title="Get the touching contact data for a body.">b2Body_GetContactData()</a></code>.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__events.html#structb2_contact_events">b2ContactEvents</a> contactEvents = <a class="code hl_function" href="group__world.html#ga96712bb6c08d335ffa37f7d30404a0e7">b2World_GetContactEvents</a>(myWorldId);</div>
<div class="ttc" id="agroup__events_html_structb2_contact_events"><div class="ttname"><a href="group__events.html#structb2_contact_events">b2ContactEvents</a></div><div class="ttdoc">Contact events are buffered in the Box2D world and are available as event arrays after the time step ...</div><div class="ttdef"><b>Definition</b> types.h:1100</div></div>
<div class="ttc" id="agroup__world_html_ga96712bb6c08d335ffa37f7d30404a0e7"><div class="ttname"><a href="group__world.html#ga96712bb6c08d335ffa37f7d30404a0e7">b2World_GetContactEvents</a></div><div class="ttdeci">B2_API b2ContactEvents b2World_GetContactEvents(b2WorldId worldId)</div><div class="ttdoc">Get contact events for this current time step. The event data is transient. Do not store a reference ...</div></div>
</div><!-- fragment --><p>None of this data applies to sensors because they are handled separately. All events involve at least one dynamic body.</p>
<p>There are three kinds of contact events:</p><ol type="1">
<li>Begin touch events</li>
<li>End touch events</li>
<li>Hit events</li>
</ol>
<h3><a class="anchor" id="autotoc_md96"></a>
Contact Touch Event</h3>
<p><code><a class="el" href="group__events.html#structb2_contact_begin_touch_event" title="A begin touch event is generated when two shapes begin touching.">b2ContactBeginTouchEvent</a></code> is recorded when two shapes begin touching. These only contain the two shape ids.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; contactEvents.<a class="code hl_variable" href="group__events.html#add0fa396297688cbeb59531e91a26e44">beginCount</a>; ++i)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="group__events.html#structb2_contact_begin_touch_event">b2ContactBeginTouchEvent</a>* beginEvent = contactEvents.<a class="code hl_variable" href="group__events.html#a2f6185fb63ea5b7e3a5b231f0db288b5">beginEvents</a> + i;</div>
<div class="line">    ShapesStartTouching(beginEvent-&gt;<a class="code hl_variable" href="group__events.html#a70c5d8f83f532cfcb024631384a8e543">shapeIdA</a>, beginEvent-&gt;<a class="code hl_variable" href="group__events.html#a98ad1be4cc3ce2f1b50043b191a6c3ee">shapeIdB</a>);</div>
<div class="line">}</div>
<div class="ttc" id="agroup__events_html_a2f6185fb63ea5b7e3a5b231f0db288b5"><div class="ttname"><a href="group__events.html#a2f6185fb63ea5b7e3a5b231f0db288b5">b2ContactEvents::beginEvents</a></div><div class="ttdeci">b2ContactBeginTouchEvent * beginEvents</div><div class="ttdoc">Array of begin touch events.</div><div class="ttdef"><b>Definition</b> types.h:1102</div></div>
<div class="ttc" id="agroup__events_html_a70c5d8f83f532cfcb024631384a8e543"><div class="ttname"><a href="group__events.html#a70c5d8f83f532cfcb024631384a8e543">b2ContactBeginTouchEvent::shapeIdA</a></div><div class="ttdeci">b2ShapeId shapeIdA</div><div class="ttdoc">Id of the first shape.</div><div class="ttdef"><b>Definition</b> types.h:1050</div></div>
<div class="ttc" id="agroup__events_html_a98ad1be4cc3ce2f1b50043b191a6c3ee"><div class="ttname"><a href="group__events.html#a98ad1be4cc3ce2f1b50043b191a6c3ee">b2ContactBeginTouchEvent::shapeIdB</a></div><div class="ttdeci">b2ShapeId shapeIdB</div><div class="ttdoc">Id of the second shape.</div><div class="ttdef"><b>Definition</b> types.h:1053</div></div>
<div class="ttc" id="agroup__events_html_add0fa396297688cbeb59531e91a26e44"><div class="ttname"><a href="group__events.html#add0fa396297688cbeb59531e91a26e44">b2ContactEvents::beginCount</a></div><div class="ttdeci">int beginCount</div><div class="ttdoc">Number of begin touch events.</div><div class="ttdef"><b>Definition</b> types.h:1111</div></div>
<div class="ttc" id="agroup__events_html_structb2_contact_begin_touch_event"><div class="ttname"><a href="group__events.html#structb2_contact_begin_touch_event">b2ContactBeginTouchEvent</a></div><div class="ttdoc">A begin touch event is generated when two shapes begin touching.</div><div class="ttdef"><b>Definition</b> types.h:1048</div></div>
</div><!-- fragment --><p><code><a class="el" href="group__events.html#structb2_contact_end_touch_event" title="An end touch event is generated when two shapes stop touching.">b2ContactEndTouchEvent</a></code> is recorded when two shapes stop touching. These only contain the two shape ids.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; contactEvents.<a class="code hl_variable" href="group__events.html#ade55bef6bed3e2b23b1be1fcd6887f9b">endCount</a>; ++i)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="group__events.html#structb2_contact_end_touch_event">b2ContactEndTouchEvent</a>* endEvent = contactEvents.<a class="code hl_variable" href="group__events.html#adc2ccea79b76d3252fea19366798202f">endEvents</a> + i;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Use b2Shape_IsValid because a shape may have been destroyed</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="group__shape.html#ga48f3b596f9ae950c7b3c752528808476">b2Shape_IsValid</a>(endEvent-&gt;<a class="code hl_variable" href="group__events.html#a9f500db2317884404aa59c595bfdda64">shapeIdA</a>) &amp;&amp; <a class="code hl_function" href="group__shape.html#ga48f3b596f9ae950c7b3c752528808476">b2Shape_IsValid</a>(endEvent-&gt;<a class="code hl_variable" href="group__events.html#a4daaecc94e891b42f01a10a9c10f7bbb">shapeIdB</a>))</div>
<div class="line">    {</div>
<div class="line">        ShapesStopTouching(endEvent-&gt;<a class="code hl_variable" href="group__events.html#a9f500db2317884404aa59c595bfdda64">shapeIdA</a>, endEvent-&gt;<a class="code hl_variable" href="group__events.html#a4daaecc94e891b42f01a10a9c10f7bbb">shapeIdB</a>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__events_html_a4daaecc94e891b42f01a10a9c10f7bbb"><div class="ttname"><a href="group__events.html#a4daaecc94e891b42f01a10a9c10f7bbb">b2ContactEndTouchEvent::shapeIdB</a></div><div class="ttdeci">b2ShapeId shapeIdB</div><div class="ttdoc">Id of the second shape.</div><div class="ttdef"><b>Definition</b> types.h:1074</div></div>
<div class="ttc" id="agroup__events_html_a9f500db2317884404aa59c595bfdda64"><div class="ttname"><a href="group__events.html#a9f500db2317884404aa59c595bfdda64">b2ContactEndTouchEvent::shapeIdA</a></div><div class="ttdeci">b2ShapeId shapeIdA</div><div class="ttdoc">Id of the first shape.</div><div class="ttdef"><b>Definition</b> types.h:1069</div></div>
<div class="ttc" id="agroup__events_html_adc2ccea79b76d3252fea19366798202f"><div class="ttname"><a href="group__events.html#adc2ccea79b76d3252fea19366798202f">b2ContactEvents::endEvents</a></div><div class="ttdeci">b2ContactEndTouchEvent * endEvents</div><div class="ttdoc">Array of end touch events.</div><div class="ttdef"><b>Definition</b> types.h:1105</div></div>
<div class="ttc" id="agroup__events_html_ade55bef6bed3e2b23b1be1fcd6887f9b"><div class="ttname"><a href="group__events.html#ade55bef6bed3e2b23b1be1fcd6887f9b">b2ContactEvents::endCount</a></div><div class="ttdeci">int endCount</div><div class="ttdoc">Number of end touch events.</div><div class="ttdef"><b>Definition</b> types.h:1114</div></div>
<div class="ttc" id="agroup__events_html_structb2_contact_end_touch_event"><div class="ttname"><a href="group__events.html#structb2_contact_end_touch_event">b2ContactEndTouchEvent</a></div><div class="ttdoc">An end touch event is generated when two shapes stop touching.</div><div class="ttdef"><b>Definition</b> types.h:1065</div></div>
</div><!-- fragment --><p>Similar to <code><a class="el" href="group__events.html#structb2_sensor_end_touch_event" title="An end touch event is generated when a shape stops overlapping a sensor shape.">b2SensorEndTouchEvent</a></code>, <code><a class="el" href="group__events.html#structb2_contact_end_touch_event" title="An end touch event is generated when two shapes stop touching.">b2ContactEndTouchEvent</a></code> may be generated due to a user operation, such as destroying a body or shape. These events are included with simulation events after the next <code>b2World_Step</code>.</p>
<p>Shapes only generate begin and end touch events if <code><a class="el" href="group__shape.html#a8a4ee544cccf26c2faacbbb5ba9f8d3c" title="Enable contact events for this shape. Only applies to kinematic and dynamic bodies....">b2ShapeDef::enableContactEvents</a></code> is true.</p>
<h3><a class="anchor" id="autotoc_md97"></a>
Hit Events</h3>
<p>Typically in games you are mainly concerned about getting contact events for when two shapes collide at a significant speed so you can play a sound and/or particle effect. Hit events are the answer for this.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; contactEvents.<a class="code hl_variable" href="group__events.html#a1faa3caeb5851df278c028d759e25a7b">hitCount</a>; ++i)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="group__events.html#structb2_contact_hit_event">b2ContactHitEvent</a>* hitEvent = contactEvents.<a class="code hl_variable" href="group__events.html#a95c01c5482e19410e57af65d977606cf">hitEvents</a> + i;</div>
<div class="line">    <span class="keywordflow">if</span> (hitEvent-&gt;<a class="code hl_variable" href="group__events.html#a43fd5e819788ceb16c5f9e623c5d354b">approachSpeed</a> &gt; 10.0f)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// play sound</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__events_html_a1faa3caeb5851df278c028d759e25a7b"><div class="ttname"><a href="group__events.html#a1faa3caeb5851df278c028d759e25a7b">b2ContactEvents::hitCount</a></div><div class="ttdeci">int hitCount</div><div class="ttdoc">Number of hit events.</div><div class="ttdef"><b>Definition</b> types.h:1117</div></div>
<div class="ttc" id="agroup__events_html_a43fd5e819788ceb16c5f9e623c5d354b"><div class="ttname"><a href="group__events.html#a43fd5e819788ceb16c5f9e623c5d354b">b2ContactHitEvent::approachSpeed</a></div><div class="ttdeci">float approachSpeed</div><div class="ttdoc">The speed the shapes are approaching. Always positive. Typically in meters per second.</div><div class="ttdef"><b>Definition</b> types.h:1093</div></div>
<div class="ttc" id="agroup__events_html_a95c01c5482e19410e57af65d977606cf"><div class="ttname"><a href="group__events.html#a95c01c5482e19410e57af65d977606cf">b2ContactEvents::hitEvents</a></div><div class="ttdeci">b2ContactHitEvent * hitEvents</div><div class="ttdoc">Array of hit events.</div><div class="ttdef"><b>Definition</b> types.h:1108</div></div>
<div class="ttc" id="agroup__events_html_structb2_contact_hit_event"><div class="ttname"><a href="group__events.html#structb2_contact_hit_event">b2ContactHitEvent</a></div><div class="ttdoc">A hit touch event is generated when two shapes collide with a speed faster than the hit speed thresho...</div><div class="ttdef"><b>Definition</b> types.h:1079</div></div>
</div><!-- fragment --><p>Shapes only generate hit events if <code><a class="el" href="group__shape.html#aaff54dfba807092f20cb0ea1b0bbbfbf" title="Enable hit events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors....">b2ShapeDef::enableHitEvents</a></code> is true. I recommend you only enable this for shapes that need hit events because it creates some overhead. Box2D also only reports hit events that have an approach speed larger than <code><a class="el" href="group__world.html#a8fad064bf7a90119a4e4690b137afc4f" title="Threshold speed for hit events. Usually meters per second.">b2WorldDef::hitEventThreshold</a></code>.</p>
<h2><a class="anchor" id="autotoc_md98"></a>
Contact Filtering</h2>
<p>Often in a game you don't want all objects to collide. For example, you may want to create a door that only certain characters can pass through. This is called contact filtering, because some interactions are filtered out.</p>
<p>Contact filtering is setup on shapes and is covered <a class="el" href="#filtering">here</a>.</p>
<h2><a class="anchor" id="autotoc_md99"></a>
Advanced Contact Handling</h2>
<h3><a class="anchor" id="autotoc_md100"></a>
Custom Filtering Callback</h3>
<p>For the best performance, use the contact filtering provided by <code><a class="el" href="group__shape.html#structb2_filter" title="This is used to filter collision on shapes.">b2Filter</a></code>. However, in some cases you may need custom filtering. You can do this by registering a custom filter callback that implements <code><a class="el" href="group__world.html#gaf224d1619b8039789d560ef4e800a7df" title="Prototype for a contact filter callback.">b2CustomFilterFcn()</a></code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> MyCustomFilter(<a class="code hl_struct" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeIdA, <a class="code hl_struct" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeIdB, <span class="keywordtype">void</span>* context)</div>
<div class="line">{</div>
<div class="line">    MyGame* myGame = context;</div>
<div class="line">    <span class="keywordflow">return</span> myGame-&gt;WantsCollision(shapeIdA, shapeIdB);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Elsewhere</span></div>
<div class="line"><a class="code hl_function" href="group__world.html#ga534c233ca11a91e3dc6a84dc90c02e05">b2World_SetCustomFilterCallback</a>(myWorldId, MyCustomFilter, myGame);</div>
<div class="ttc" id="agroup__world_html_ga534c233ca11a91e3dc6a84dc90c02e05"><div class="ttname"><a href="group__world.html#ga534c233ca11a91e3dc6a84dc90c02e05">b2World_SetCustomFilterCallback</a></div><div class="ttdeci">B2_API void b2World_SetCustomFilterCallback(b2WorldId worldId, b2CustomFilterFcn *fcn, void *context)</div><div class="ttdoc">Register the custom filter callback. This is optional.</div></div>
</div><!-- fragment --><p>This function must be <a href="https://en.wikipedia.org/wiki/Thread_safety">thread-safe</a> and must not read from or write to the Box2D world. Otherwise you will get a <a href="https://en.wikipedia.org/wiki/Race_condition">race condition</a>.</p>
<h3><a class="anchor" id="autotoc_md101"></a>
Pre-Solve Callback</h3>
<p>This is called after collision detection, but before collision resolution. This gives you a chance to disable the contact based on the contact geometry. For example, you can implement a one-sided platform using this callback.</p>
<p>The contact will be re-enabled each time through collision processing, so you will need to disable the contact every time-step. This function must be thread-safe and must not read from or write to the Box2D world.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> MyPreSolve(<a class="code hl_struct" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeIdA, <a class="code hl_struct" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeIdB, <a class="code hl_struct" href="group__collision.html#structb2_manifold">b2Manifold</a>* manifold, <span class="keywordtype">void</span>* context)</div>
<div class="line">{</div>
<div class="line">    MyGame* myGame = context;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (myGame-&gt;IsHittingBelowPlatform(shapeIdA, shapeIdB, manifold))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Elsewhere</span></div>
<div class="line"><a class="code hl_function" href="group__world.html#gae6aa7772a42d6389c05947dae00d7d01">b2World_SetPreSolveCallback</a>(myWorldId, MyPreSolve, myGame);</div>
<div class="ttc" id="agroup__collision_html_structb2_manifold"><div class="ttname"><a href="group__collision.html#structb2_manifold">b2Manifold</a></div><div class="ttdoc">A contact manifold describes the contact points between colliding shapes.</div><div class="ttdef"><b>Definition</b> collision.h:539</div></div>
<div class="ttc" id="agroup__world_html_gae6aa7772a42d6389c05947dae00d7d01"><div class="ttname"><a href="group__world.html#gae6aa7772a42d6389c05947dae00d7d01">b2World_SetPreSolveCallback</a></div><div class="ttdeci">B2_API void b2World_SetPreSolveCallback(b2WorldId worldId, b2PreSolveFcn *fcn, void *context)</div><div class="ttdoc">Register the pre-solve callback. This is optional.</div></div>
</div><!-- fragment --><p>Note this currently does not work with high speed collisions, so you may see a pause in those situations.</p>
<p>See the <code>Platformer</code> sample for more details.</p>
<h1><a class="anchor" id="autotoc_md102"></a>
Joints</h1>
<p>Joints are used to constrain bodies to the world or to each other. Typical examples in games include ragdolls, teeters, and pulleys. Joints can be combined in many different ways to create interesting motions.</p>
<p>Some joints provide limits so you can control the range of motion. Some joints provide motors which can be used to drive the joint at a prescribed speed until a prescribed force/torque is exceeded. And some joints provide springs with damping.</p>
<p>Joint motors can be used in many ways. You can use motors to control position by specifying a joint velocity that is proportional to the difference between the actual and desired position. You can also use motors to simulate joint friction: set the joint velocity to zero and provide a small, but significant maximum motor force/torque. Then the motor will attempt to keep the joint from moving until the load becomes too strong.</p>
<h2><a class="anchor" id="autotoc_md103"></a>
Joint Definition</h2>
<p>Each joint type has an associated joint definition. All joints are connected between two different bodies. One body may be static. Joints between static and/or kinematic bodies are allowed, but have no effect and use some processing time.</p>
<p>If a joint is connected to a disabled body, that joint is effectively disabled. When the both bodies on a joint become enabled, the joint will automatically be enabled as well. In other words, you do not need to explicitly enable or disable a joint.</p>
<p>You can specify user data for any joint type and you can provide a flag to prevent the attached bodies from colliding with each other. This is the default behavior and you must set the <code>collideConnected</code> Boolean to allow collision between two connected bodies.</p>
<p>Many joint definitions require that you provide some geometric data. Often a joint will be defined by anchor points. These are points fixed in the attached bodies. Box2D requires these points to be specified in local coordinates. This way the joint can be specified even when the current body transforms violate the joint constraint. Additionally, some joint definitions need a reference angle between the bodies. This may be necessary to constrain rotation correctly.</p>
<p>The rest of the joint definition data depends on the joint type. I cover these below.</p>
<h2><a class="anchor" id="autotoc_md104"></a>
Joint Lifetime</h2>
<p>Joints are created using creation functions supplied for each joint type. They are destroyed with a shared function. All joint types share a single id type <code><a class="el" href="group__id.html#structb2_joint_id" title="Joint id references a joint instance. This should be treated as an opaque handle.">b2JointId</a></code>.</p>
<p>Here's an example of the lifetime of a revolute joint:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__revolute__joint.html#structb2_revolute_joint_def">b2RevoluteJointDef</a> jointDef = <a class="code hl_function" href="group__revolute__joint.html#ga5cf7e7f8824feac112c75c0d44cc6ea3">b2DefaultRevoluteJointDef</a>();</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__revolute__joint.html#a87f1685b4c79a39f100cecb8b097b158">bodyIdA</a> = myBodyA;</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__revolute__joint.html#ac2d92f6d6e1c89f4e1fc0f2b0a3cb337">bodyIdB</a> = myBodyB;</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__revolute__joint.html#a76337d07aa63232a7b20d50decc862ae">localAnchorA</a> = (<a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a>){0.0f, 0.0f};</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__revolute__joint.html#a3f33bc1d9f6c22043a5ff2f1d89f04e0">localAnchorB</a> = (<a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a>){1.0f, 2.0f};</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="group__id.html#structb2_joint_id">b2JointId</a> myJointId = <a class="code hl_function" href="group__revolute__joint.html#ga9227997192504e87966adab128f4dd2f">b2CreateRevoluteJoint</a>(myWorldId, &amp;jointDef);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... do stuff ...</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__joint.html#gad274f26c6ef7e1e21b7238e6254038bd">b2DestroyJoint</a>(myJointId);</div>
<div class="line">myJointId = b2_nullJointId;</div>
<div class="ttc" id="agroup__id_html_structb2_joint_id"><div class="ttname"><a href="group__id.html#structb2_joint_id">b2JointId</a></div><div class="ttdoc">Joint id references a joint instance. This should be treated as an opaque handle.</div><div class="ttdef"><b>Definition</b> id.h:69</div></div>
<div class="ttc" id="agroup__joint_html_gad274f26c6ef7e1e21b7238e6254038bd"><div class="ttname"><a href="group__joint.html#gad274f26c6ef7e1e21b7238e6254038bd">b2DestroyJoint</a></div><div class="ttdeci">B2_API void b2DestroyJoint(b2JointId jointId)</div><div class="ttdoc">Destroy a joint.</div></div>
<div class="ttc" id="agroup__revolute__joint_html_a3f33bc1d9f6c22043a5ff2f1d89f04e0"><div class="ttname"><a href="group__revolute__joint.html#a3f33bc1d9f6c22043a5ff2f1d89f04e0">b2RevoluteJointDef::localAnchorB</a></div><div class="ttdeci">b2Vec2 localAnchorB</div><div class="ttdoc">The local anchor point relative to bodyB&#39;s origin.</div><div class="ttdef"><b>Definition</b> types.h:791</div></div>
<div class="ttc" id="agroup__revolute__joint_html_a76337d07aa63232a7b20d50decc862ae"><div class="ttname"><a href="group__revolute__joint.html#a76337d07aa63232a7b20d50decc862ae">b2RevoluteJointDef::localAnchorA</a></div><div class="ttdeci">b2Vec2 localAnchorA</div><div class="ttdoc">The local anchor point relative to bodyA&#39;s origin.</div><div class="ttdef"><b>Definition</b> types.h:788</div></div>
<div class="ttc" id="agroup__revolute__joint_html_a87f1685b4c79a39f100cecb8b097b158"><div class="ttname"><a href="group__revolute__joint.html#a87f1685b4c79a39f100cecb8b097b158">b2RevoluteJointDef::bodyIdA</a></div><div class="ttdeci">b2BodyId bodyIdA</div><div class="ttdoc">The first attached body.</div><div class="ttdef"><b>Definition</b> types.h:782</div></div>
<div class="ttc" id="agroup__revolute__joint_html_ac2d92f6d6e1c89f4e1fc0f2b0a3cb337"><div class="ttname"><a href="group__revolute__joint.html#ac2d92f6d6e1c89f4e1fc0f2b0a3cb337">b2RevoluteJointDef::bodyIdB</a></div><div class="ttdeci">b2BodyId bodyIdB</div><div class="ttdoc">The second attached body.</div><div class="ttdef"><b>Definition</b> types.h:785</div></div>
<div class="ttc" id="agroup__revolute__joint_html_ga5cf7e7f8824feac112c75c0d44cc6ea3"><div class="ttname"><a href="group__revolute__joint.html#ga5cf7e7f8824feac112c75c0d44cc6ea3">b2DefaultRevoluteJointDef</a></div><div class="ttdeci">b2RevoluteJointDef b2DefaultRevoluteJointDef(void)</div><div class="ttdoc">Use this to initialize your joint definition.</div></div>
<div class="ttc" id="agroup__revolute__joint_html_ga9227997192504e87966adab128f4dd2f"><div class="ttname"><a href="group__revolute__joint.html#ga9227997192504e87966adab128f4dd2f">b2CreateRevoluteJoint</a></div><div class="ttdeci">B2_API b2JointId b2CreateRevoluteJoint(b2WorldId worldId, const b2RevoluteJointDef *def)</div><div class="ttdoc">Create a revolute joint.</div></div>
<div class="ttc" id="agroup__revolute__joint_html_structb2_revolute_joint_def"><div class="ttname"><a href="group__revolute__joint.html#structb2_revolute_joint_def">b2RevoluteJointDef</a></div><div class="ttdoc">Revolute joint definition.</div><div class="ttdef"><b>Definition</b> types.h:780</div></div>
</div><!-- fragment --><p>It is always good to nullify your ids after they are destroyed.</p>
<p>Joint lifetime is related to body lifetime. Joints cannot exist detached from a body. So when a body is destroyed, all joints attached to that body are automatically destroyed. This means you need to be careful to avoid using joint ids when the attached body was destroyed. Box2D will assert if you use a dangling joint id.</p>
<blockquote class="doxtable">
<p><b>Caution</b>: Joints are destroyed when an attached body is destroyed. </p>
</blockquote>
<p>Fortunately you can check if your joint id is valid.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="group__joint.html#ga4ddbea8f07d8049e84ff3a8dd5789cbc">b2Joint_IsValid</a>(myJointId) == <span class="keyword">false</span>)</div>
<div class="line">{</div>
<div class="line">    myJointId = b2_nullJointId;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__joint_html_ga4ddbea8f07d8049e84ff3a8dd5789cbc"><div class="ttname"><a href="group__joint.html#ga4ddbea8f07d8049e84ff3a8dd5789cbc">b2Joint_IsValid</a></div><div class="ttdeci">B2_API bool b2Joint_IsValid(b2JointId id)</div><div class="ttdoc">Joint identifier validation. Provides validation for up to 64K allocations.</div></div>
</div><!-- fragment --><p>This is certainly useful, but should not be overused because if you are creating and destroying many joints, this may eventually alias to a different joint. All ids have a limit of 64k generations.</p>
<h2><a class="anchor" id="autotoc_md105"></a>
Using Joints</h2>
<p>Many simulations create the joints and don't access them again until they are destroyed. However, there is a lot of useful data contained in joints that you can use to create a rich simulation.</p>
<p>First of all, you can get the type, bodies, anchor points, and user data from a joint.</p>
<div class="fragment"><div class="line"><a class="code hl_enumeration" href="group__joint.html#ga0bb202d8a286c888a11985b07b2272ab">b2JointType</a> jointType = <a class="code hl_function" href="group__joint.html#ga0a116790ef2fc67fd3f95672d224e77a">b2Joint_GetType</a>(myJointId);</div>
<div class="line"><a class="code hl_struct" href="group__id.html#structb2_body_id">b2BodyId</a> bodyIdA = <a class="code hl_function" href="group__joint.html#ga992fd9266b943890445508e079f8ca50">b2Joint_GetBodyA</a>(myJointId);</div>
<div class="line"><a class="code hl_struct" href="group__id.html#structb2_body_id">b2BodyId</a> bodyIdB = <a class="code hl_function" href="group__joint.html#ga8e26cf332c22323d36d805786de851af">b2Joint_GetBodyB</a>(myJointId);</div>
<div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> localAnchorA = <a class="code hl_function" href="group__joint.html#ga57cca9d4c338a0963576086c1e032aef">b2Joint_GetLocalAnchorA</a>(myJointId);</div>
<div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> localAnchorB = <a class="code hl_function" href="group__joint.html#gaa90b0b0c6ed839fd5a63c19d23b519c9">b2Joint_GetLocalAnchorB</a>(myJointId);</div>
<div class="line"><span class="keywordtype">void</span>* myUserData = <a class="code hl_function" href="group__joint.html#ga0ccd403d6dadf2f94bb0c64d7e2228cd">b2Joint_GetUserData</a>(myJointId);</div>
<div class="ttc" id="agroup__joint_html_ga0a116790ef2fc67fd3f95672d224e77a"><div class="ttname"><a href="group__joint.html#ga0a116790ef2fc67fd3f95672d224e77a">b2Joint_GetType</a></div><div class="ttdeci">B2_API b2JointType b2Joint_GetType(b2JointId jointId)</div><div class="ttdoc">Get the joint type.</div></div>
<div class="ttc" id="agroup__joint_html_ga0bb202d8a286c888a11985b07b2272ab"><div class="ttname"><a href="group__joint.html#ga0bb202d8a286c888a11985b07b2272ab">b2JointType</a></div><div class="ttdeci">b2JointType</div><div class="ttdoc">Joint type enumeration.</div><div class="ttdef"><b>Definition</b> types.h:520</div></div>
<div class="ttc" id="agroup__joint_html_ga0ccd403d6dadf2f94bb0c64d7e2228cd"><div class="ttname"><a href="group__joint.html#ga0ccd403d6dadf2f94bb0c64d7e2228cd">b2Joint_GetUserData</a></div><div class="ttdeci">B2_API void * b2Joint_GetUserData(b2JointId jointId)</div><div class="ttdoc">Get the user data on a joint.</div></div>
<div class="ttc" id="agroup__joint_html_ga57cca9d4c338a0963576086c1e032aef"><div class="ttname"><a href="group__joint.html#ga57cca9d4c338a0963576086c1e032aef">b2Joint_GetLocalAnchorA</a></div><div class="ttdeci">B2_API b2Vec2 b2Joint_GetLocalAnchorA(b2JointId jointId)</div><div class="ttdoc">Get the local anchor on bodyA.</div></div>
<div class="ttc" id="agroup__joint_html_ga8e26cf332c22323d36d805786de851af"><div class="ttname"><a href="group__joint.html#ga8e26cf332c22323d36d805786de851af">b2Joint_GetBodyB</a></div><div class="ttdeci">B2_API b2BodyId b2Joint_GetBodyB(b2JointId jointId)</div><div class="ttdoc">Get body B id on a joint.</div></div>
<div class="ttc" id="agroup__joint_html_ga992fd9266b943890445508e079f8ca50"><div class="ttname"><a href="group__joint.html#ga992fd9266b943890445508e079f8ca50">b2Joint_GetBodyA</a></div><div class="ttdeci">B2_API b2BodyId b2Joint_GetBodyA(b2JointId jointId)</div><div class="ttdoc">Get body A id on a joint.</div></div>
<div class="ttc" id="agroup__joint_html_gaa90b0b0c6ed839fd5a63c19d23b519c9"><div class="ttname"><a href="group__joint.html#gaa90b0b0c6ed839fd5a63c19d23b519c9">b2Joint_GetLocalAnchorB</a></div><div class="ttdeci">B2_API b2Vec2 b2Joint_GetLocalAnchorB(b2JointId jointId)</div><div class="ttdoc">Get the local anchor on bodyB.</div></div>
</div><!-- fragment --><p>All joints have a reaction force and torque. Reaction forces are related to the <a href="https://en.wikipedia.org/wiki/Free_body_diagram">free body diagram</a>. The Box2D convention is that the reaction force is applied to body B at the anchor point. You can use reaction forces to break joints or trigger other game events. These functions may do some computations, so don't call them if you don't need the result.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> force = <a class="code hl_function" href="group__joint.html#ga8333a4a0e9a76d71492aa66bc71eb362">b2Joint_GetConstraintForce</a>(myJointId);</div>
<div class="line"><span class="keywordtype">float</span> torque = <a class="code hl_function" href="group__joint.html#gabe282129f1cdd6cc298dea4d3468bf82">b2Joint_GetConstraintTorque</a>(myJointId);</div>
<div class="ttc" id="agroup__joint_html_ga8333a4a0e9a76d71492aa66bc71eb362"><div class="ttname"><a href="group__joint.html#ga8333a4a0e9a76d71492aa66bc71eb362">b2Joint_GetConstraintForce</a></div><div class="ttdeci">B2_API b2Vec2 b2Joint_GetConstraintForce(b2JointId jointId)</div><div class="ttdoc">Get the current constraint force for this joint. Usually in Newtons.</div></div>
<div class="ttc" id="agroup__joint_html_gabe282129f1cdd6cc298dea4d3468bf82"><div class="ttname"><a href="group__joint.html#gabe282129f1cdd6cc298dea4d3468bf82">b2Joint_GetConstraintTorque</a></div><div class="ttdeci">B2_API float b2Joint_GetConstraintTorque(b2JointId jointId)</div><div class="ttdoc">Get the current constraint torque for this joint. Usually in Newton * meters.</div></div>
</div><!-- fragment --><p>See the sample <code>BreakableJoint</code> for more details.</p>
<h2><a class="anchor" id="autotoc_md106"></a>
Distance Joint</h2>
<p>One of the simplest joints is a distance joint which says that the distance between two points on two bodies must be constant. When you specify a distance joint the two bodies should already be in place. Then you specify the two anchor points in local coordinates. The first anchor point is connected to body A, and the second anchor point is connected to body B. These points imply the length of the distance constraint.</p>
<div class="image">
<object type="image/svg+xml" data="distance_joint.svg" style="pointer-events: none;"></object>
<div class="caption">
Distance Joint</div></div>
    <p>Here is an example of a distance joint definition. In this case I decided to allow the bodies to collide.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__distance__joint.html#structb2_distance_joint_def">b2DistanceJointDef</a> jointDef = <a class="code hl_function" href="group__distance__joint.html#ga060ad87dbc7f44df28f9a9157907cc2c">b2DefaultDistanceJointDef</a>();</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__distance__joint.html#a573b68cd33c7ce82bd8040f2a3a90b8c">bodyIdA</a> = myBodyIdA;</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__distance__joint.html#a50b997904366393c5834de4bcfda4d0e">bodyIdB</a> = myBodyIdB;</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__distance__joint.html#a15c7a75fa277e2056bf1b44198658518">localAnchorA</a> = (<a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a>){1.0f, -3.0f};</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__distance__joint.html#a3c8995be726238eee084af750442255c">localAnchorB</a> = (<a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a>){0.0f, 0.5f};</div>
<div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> anchorA = <a class="code hl_function" href="group__body.html#gad92a168eb3618448a336bfa88ac4d9a7">b2Body_GetWorldPoint</a>(myBodyIdA, jointDef.<a class="code hl_variable" href="group__distance__joint.html#a15c7a75fa277e2056bf1b44198658518">localAnchorA</a>);</div>
<div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> anchorB = <a class="code hl_function" href="group__body.html#gad92a168eb3618448a336bfa88ac4d9a7">b2Body_GetWorldPoint</a>(myBodyIdB, jointDef.<a class="code hl_variable" href="group__distance__joint.html#a3c8995be726238eee084af750442255c">localAnchorB</a>);</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__distance__joint.html#a001acbbd67326ab5e5d5ec6dc64faf78">length</a> = <a class="code hl_function" href="group__math.html#gacf68e49723e512e1fadf297e6f0940d1">b2Distance</a>(anchorA, anchorB);</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__distance__joint.html#a1a7fb6eef1f6220320260935c4954597">collideConnected</a> = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="group__id.html#structb2_joint_id">b2JointId</a> myJointId = <a class="code hl_function" href="group__distance__joint.html#ga37f43d5f957fbd1e8228a33aeeca260b">b2CreateDistanceJoint</a>(myWorldId, &amp;jointDef);</div>
<div class="ttc" id="agroup__distance__joint_html_a001acbbd67326ab5e5d5ec6dc64faf78"><div class="ttname"><a href="group__distance__joint.html#a001acbbd67326ab5e5d5ec6dc64faf78">b2DistanceJointDef::length</a></div><div class="ttdeci">float length</div><div class="ttdoc">The rest length of this joint. Clamped to a stable minimum value.</div><div class="ttdef"><b>Definition</b> types.h:553</div></div>
<div class="ttc" id="agroup__distance__joint_html_a15c7a75fa277e2056bf1b44198658518"><div class="ttname"><a href="group__distance__joint.html#a15c7a75fa277e2056bf1b44198658518">b2DistanceJointDef::localAnchorA</a></div><div class="ttdeci">b2Vec2 localAnchorA</div><div class="ttdoc">The local anchor point relative to bodyA&#39;s origin.</div><div class="ttdef"><b>Definition</b> types.h:547</div></div>
<div class="ttc" id="agroup__distance__joint_html_a1a7fb6eef1f6220320260935c4954597"><div class="ttname"><a href="group__distance__joint.html#a1a7fb6eef1f6220320260935c4954597">b2DistanceJointDef::collideConnected</a></div><div class="ttdeci">bool collideConnected</div><div class="ttdoc">Set this flag to true if the attached bodies should collide.</div><div class="ttdef"><b>Definition</b> types.h:584</div></div>
<div class="ttc" id="agroup__distance__joint_html_a3c8995be726238eee084af750442255c"><div class="ttname"><a href="group__distance__joint.html#a3c8995be726238eee084af750442255c">b2DistanceJointDef::localAnchorB</a></div><div class="ttdeci">b2Vec2 localAnchorB</div><div class="ttdoc">The local anchor point relative to bodyB&#39;s origin.</div><div class="ttdef"><b>Definition</b> types.h:550</div></div>
<div class="ttc" id="agroup__distance__joint_html_a50b997904366393c5834de4bcfda4d0e"><div class="ttname"><a href="group__distance__joint.html#a50b997904366393c5834de4bcfda4d0e">b2DistanceJointDef::bodyIdB</a></div><div class="ttdeci">b2BodyId bodyIdB</div><div class="ttdoc">The second attached body.</div><div class="ttdef"><b>Definition</b> types.h:544</div></div>
<div class="ttc" id="agroup__distance__joint_html_a573b68cd33c7ce82bd8040f2a3a90b8c"><div class="ttname"><a href="group__distance__joint.html#a573b68cd33c7ce82bd8040f2a3a90b8c">b2DistanceJointDef::bodyIdA</a></div><div class="ttdeci">b2BodyId bodyIdA</div><div class="ttdoc">The first attached body.</div><div class="ttdef"><b>Definition</b> types.h:541</div></div>
<div class="ttc" id="agroup__distance__joint_html_ga060ad87dbc7f44df28f9a9157907cc2c"><div class="ttname"><a href="group__distance__joint.html#ga060ad87dbc7f44df28f9a9157907cc2c">b2DefaultDistanceJointDef</a></div><div class="ttdeci">b2DistanceJointDef b2DefaultDistanceJointDef(void)</div><div class="ttdoc">Use this to initialize your joint definition.</div></div>
<div class="ttc" id="agroup__distance__joint_html_ga37f43d5f957fbd1e8228a33aeeca260b"><div class="ttname"><a href="group__distance__joint.html#ga37f43d5f957fbd1e8228a33aeeca260b">b2CreateDistanceJoint</a></div><div class="ttdeci">B2_API b2JointId b2CreateDistanceJoint(b2WorldId worldId, const b2DistanceJointDef *def)</div><div class="ttdoc">Create a distance joint.</div></div>
<div class="ttc" id="agroup__distance__joint_html_structb2_distance_joint_def"><div class="ttname"><a href="group__distance__joint.html#structb2_distance_joint_def">b2DistanceJointDef</a></div><div class="ttdoc">Distance joint definition.</div><div class="ttdef"><b>Definition</b> types.h:539</div></div>
<div class="ttc" id="agroup__math_html_gacf68e49723e512e1fadf297e6f0940d1"><div class="ttname"><a href="group__math.html#gacf68e49723e512e1fadf297e6f0940d1">b2Distance</a></div><div class="ttdeci">float b2Distance(b2Vec2 a, b2Vec2 b)</div><div class="ttdoc">Get the distance between two points.</div><div class="ttdef"><b>Definition</b> math_functions.h:272</div></div>
</div><!-- fragment --><p>The distance joint can also be made soft, like a spring-damper connection. Softness is achieved by enabling the spring and tuning two values in the definition: Hertz and damping ratio.</p>
<div class="fragment"><div class="line">jointDef.<a class="code hl_variable" href="group__distance__joint.html#a593fdde24593e6b5de9ec706b37b7014">enableSpring</a> = <span class="keyword">true</span>;</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__distance__joint.html#ae8b1bf0b2a9d447e940a59f342e8dcfb">hertz</a> = 2.0f;</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__distance__joint.html#a35db4b2f47e877ba722e5f1112e98b28">dampingRatio</a> = 0.5f;</div>
<div class="ttc" id="agroup__distance__joint_html_a35db4b2f47e877ba722e5f1112e98b28"><div class="ttname"><a href="group__distance__joint.html#a35db4b2f47e877ba722e5f1112e98b28">b2DistanceJointDef::dampingRatio</a></div><div class="ttdeci">float dampingRatio</div><div class="ttdoc">The spring linear damping ratio, non-dimensional.</div><div class="ttdef"><b>Definition</b> types.h:563</div></div>
<div class="ttc" id="agroup__distance__joint_html_a593fdde24593e6b5de9ec706b37b7014"><div class="ttname"><a href="group__distance__joint.html#a593fdde24593e6b5de9ec706b37b7014">b2DistanceJointDef::enableSpring</a></div><div class="ttdeci">bool enableSpring</div><div class="ttdoc">Enable the distance constraint to behave like a spring.</div><div class="ttdef"><b>Definition</b> types.h:557</div></div>
<div class="ttc" id="agroup__distance__joint_html_ae8b1bf0b2a9d447e940a59f342e8dcfb"><div class="ttname"><a href="group__distance__joint.html#ae8b1bf0b2a9d447e940a59f342e8dcfb">b2DistanceJointDef::hertz</a></div><div class="ttdeci">float hertz</div><div class="ttdoc">The spring linear stiffness Hertz, cycles per second.</div><div class="ttdef"><b>Definition</b> types.h:560</div></div>
</div><!-- fragment --><p>The hertz is the frequency of a <a href="https://en.wikipedia.org/wiki/Harmonic_oscillator">harmonic oscillator</a> (like a guitar string). Typically the frequency should be less than a half the frequency of the time step. So if you are using a 60Hz time step, the frequency of the distance joint should be less than 30Hz. The reason is related to the <a href="https://en.wikipedia.org/wiki/Nyquist_frequency">Nyquist frequency</a>.</p>
<p>The damping ratio controls how fast the oscillations dissipate. A damping ratio of one is <a href="https://en.wikipedia.org/wiki/Damping">critical damping</a> and prevents oscillation.</p>
<p>It is also possible to define a minimum and maximum length for the distance joint. You can even motorize the distance joint to adjust its length dynamically. See <code><a class="el" href="group__distance__joint.html#structb2_distance_joint_def" title="Distance joint definition.">b2DistanceJointDef</a></code> and the <code>DistanceJoint</code> sample for details.</p>
<h2><a class="anchor" id="autotoc_md107"></a>
Revolute Joint</h2>
<p>A revolute joint forces two bodies to share a common anchor point, often called a hinge point or pivot. The revolute joint has a single degree of freedom: the relative rotation of the two bodies. This is called the joint angle.</p>
<div class="image">
<object type="image/svg+xml" data="revolute_joint.svg" style="pointer-events: none;"></object>
<div class="caption">
Revolute Joint</div></div>
    <p>Like all joints, the anchor points are specified in local coordinates. However, you can use the body utility functions to simplify this.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> worldPivot = {10.0f, -4.0f};</div>
<div class="line"><a class="code hl_struct" href="group__revolute__joint.html#structb2_revolute_joint_def">b2RevoluteJointDef</a> jointDef = <a class="code hl_function" href="group__revolute__joint.html#ga5cf7e7f8824feac112c75c0d44cc6ea3">b2DefaultRevoluteJointDef</a>();</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__distance__joint.html#a573b68cd33c7ce82bd8040f2a3a90b8c">bodyIdA</a> = myBodyIdA;</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__distance__joint.html#a50b997904366393c5834de4bcfda4d0e">bodyIdB</a> = myBodyIdB;</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__distance__joint.html#a15c7a75fa277e2056bf1b44198658518">localAnchorA</a> = <a class="code hl_function" href="group__body.html#gac10f227ccd433b997fe8158d0724f5b9">b2Body_GetLocalPoint</a>(myBodyIdA, worldPivot);</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__distance__joint.html#a3c8995be726238eee084af750442255c">localAnchorB</a> = <a class="code hl_function" href="group__body.html#gac10f227ccd433b997fe8158d0724f5b9">b2Body_GetLocalPoint</a>(myBodyIdB, worldPivot);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="group__id.html#structb2_joint_id">b2JointId</a> myJointId = <a class="code hl_function" href="group__revolute__joint.html#ga9227997192504e87966adab128f4dd2f">b2CreateRevoluteJoint</a>(myWorldId, &amp;jointDef);</div>
</div><!-- fragment --><p>The revolute joint angle is positive when bodyB rotates counter-clockwise about the anchor point. Like all angles in Box2D, the revolute angle is measured in radians. By convention the revolute joint angle is zero when the two bodies have equal angles. You can offset this using <code><a class="el" href="group__revolute__joint.html#a7d70409545eecd92b84b3d55724019e1" title="The bodyB angle minus bodyA angle in the reference state (radians).">b2RevoluteJointDef::referenceAngle</a></code>.</p>
<p>In some cases you might wish to control the joint angle. For this, the revolute joint can simulate a joint limit and/or a motor.</p>
<p>A joint limit forces the joint angle to remain between a lower and upper angle. The limit will apply as much torque as needed to make this happen. The limit range should include zero, otherwise the joint will lurch when the simulation begins. The lower and upper limit are relative to the reference angle.</p>
<p>A joint motor allows you to specify the joint speed. The speed can be negative or positive. A motor can have infinite force, but this is usually not desirable. Recall the eternal question:</p>
<blockquote class="doxtable">
<p><em>What happens when an irresistible force meets an immovable object?</em> </p>
</blockquote>
<p>I can tell you it's not pretty. So you can provide a maximum torque for the joint motor. The joint motor will maintain the specified speed unless the required torque exceeds the specified maximum. When the maximum torque is exceeded, the joint will slow down and can even reverse.</p>
<p>You can use a joint motor to simulate joint friction. Just set the joint speed to zero, and set the maximum torque to some small, but significant value. The motor will try to prevent the joint from rotating, but will yield to a significant load.</p>
<p>Here's a revision of the revolute joint definition above; this time the joint has a limit and a motor enabled. The motor is setup to simulate joint friction.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> worldPivot = {10.0f, -4.0f};</div>
<div class="line"><a class="code hl_struct" href="group__revolute__joint.html#structb2_revolute_joint_def">b2RevoluteJointDef</a> jointDef = <a class="code hl_function" href="group__revolute__joint.html#ga5cf7e7f8824feac112c75c0d44cc6ea3">b2DefaultRevoluteJointDef</a>();</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__distance__joint.html#a573b68cd33c7ce82bd8040f2a3a90b8c">bodyIdA</a> = myBodyIdA;</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__distance__joint.html#a50b997904366393c5834de4bcfda4d0e">bodyIdB</a> = myBodyIdB;</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__distance__joint.html#a15c7a75fa277e2056bf1b44198658518">localAnchorA</a> = <a class="code hl_function" href="group__body.html#gac10f227ccd433b997fe8158d0724f5b9">b2Body_GetLocalPoint</a>(myBodyIdA, worldPivot);</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__distance__joint.html#a3c8995be726238eee084af750442255c">localAnchorB</a> = <a class="code hl_function" href="group__body.html#gac10f227ccd433b997fe8158d0724f5b9">b2Body_GetLocalPoint</a>(myBodyIdB, worldPivot);</div>
<div class="line">jointDef.lowerAngle = -0.5f * b2_pi; <span class="comment">// -90 degrees</span></div>
<div class="line">jointDef.upperAngle = 0.25f * b2_pi; <span class="comment">// 45 degrees</span></div>
<div class="line">jointDef.<a class="code hl_variable" href="group__distance__joint.html#a00e542b7324cc6a5b3e86aa8dc1dc3e2">enableLimit</a> = <span class="keyword">true</span>;</div>
<div class="line">jointDef.maxMotorTorque = 10.0f;</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__distance__joint.html#afa5a0bfb5fb84ea2457bc310b98c9574">motorSpeed</a> = 0.0f;</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__distance__joint.html#ab6017b5fb0b9be77ba08b252d1921586">enableMotor</a> = <span class="keyword">true</span>;</div>
<div class="ttc" id="agroup__distance__joint_html_a00e542b7324cc6a5b3e86aa8dc1dc3e2"><div class="ttname"><a href="group__distance__joint.html#a00e542b7324cc6a5b3e86aa8dc1dc3e2">b2DistanceJointDef::enableLimit</a></div><div class="ttdeci">bool enableLimit</div><div class="ttdoc">Enable/disable the joint limit.</div><div class="ttdef"><b>Definition</b> types.h:566</div></div>
<div class="ttc" id="agroup__distance__joint_html_ab6017b5fb0b9be77ba08b252d1921586"><div class="ttname"><a href="group__distance__joint.html#ab6017b5fb0b9be77ba08b252d1921586">b2DistanceJointDef::enableMotor</a></div><div class="ttdeci">bool enableMotor</div><div class="ttdoc">Enable/disable the joint motor.</div><div class="ttdef"><b>Definition</b> types.h:575</div></div>
<div class="ttc" id="agroup__distance__joint_html_afa5a0bfb5fb84ea2457bc310b98c9574"><div class="ttname"><a href="group__distance__joint.html#afa5a0bfb5fb84ea2457bc310b98c9574">b2DistanceJointDef::motorSpeed</a></div><div class="ttdeci">float motorSpeed</div><div class="ttdoc">The desired motor speed, usually in meters per second.</div><div class="ttdef"><b>Definition</b> types.h:581</div></div>
</div><!-- fragment --><p> You can access a revolute joint's angle, speed, and motor torque.</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> angleInRadians = <a class="code hl_function" href="group__revolute__joint.html#gaaf79f90413f31b0ddbdbb29094a666ea">b2RevoluteJoint_GetAngle</a>(myJointId);</div>
<div class="line"><span class="keywordtype">float</span> speed = <a class="code hl_function" href="group__revolute__joint.html#ga811a82b1a7f5cd18faf0bfdcc4098d46">b2RevoluteJoint_GetMotorSpeed</a>(myJointId);</div>
<div class="line"><span class="keywordtype">float</span> currentTorque = <a class="code hl_function" href="group__revolute__joint.html#ga8da4eb94b7175425ffdad8a57740a58d">b2RevoluteJoint_GetMotorTorque</a>(myJointId);</div>
<div class="ttc" id="agroup__revolute__joint_html_ga811a82b1a7f5cd18faf0bfdcc4098d46"><div class="ttname"><a href="group__revolute__joint.html#ga811a82b1a7f5cd18faf0bfdcc4098d46">b2RevoluteJoint_GetMotorSpeed</a></div><div class="ttdeci">B2_API float b2RevoluteJoint_GetMotorSpeed(b2JointId jointId)</div><div class="ttdoc">Get the revolute joint motor speed in radians per second.</div></div>
<div class="ttc" id="agroup__revolute__joint_html_ga8da4eb94b7175425ffdad8a57740a58d"><div class="ttname"><a href="group__revolute__joint.html#ga8da4eb94b7175425ffdad8a57740a58d">b2RevoluteJoint_GetMotorTorque</a></div><div class="ttdeci">B2_API float b2RevoluteJoint_GetMotorTorque(b2JointId jointId)</div><div class="ttdoc">Get the revolute joint current motor torque, usually in newton-meters.</div></div>
<div class="ttc" id="agroup__revolute__joint_html_gaaf79f90413f31b0ddbdbb29094a666ea"><div class="ttname"><a href="group__revolute__joint.html#gaaf79f90413f31b0ddbdbb29094a666ea">b2RevoluteJoint_GetAngle</a></div><div class="ttdeci">B2_API float b2RevoluteJoint_GetAngle(b2JointId jointId)</div><div class="ttdoc">Get the revolute joint current angle in radians relative to the reference angle.</div></div>
</div><!-- fragment --><p>You also update the motor parameters each step.</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__revolute__joint.html#gac8fd7b3546882fdda79777dd1127aa4e">b2RevoluteJoint_SetMotorSpeed</a>(myJointId, 20.0f);</div>
<div class="line"><a class="code hl_function" href="group__revolute__joint.html#ga9b98490a58351384764414da202e6eb7">b2RevoluteJoint_SetMaxMotorTorque</a>(myJointId, 100.0f);</div>
<div class="ttc" id="agroup__revolute__joint_html_ga9b98490a58351384764414da202e6eb7"><div class="ttname"><a href="group__revolute__joint.html#ga9b98490a58351384764414da202e6eb7">b2RevoluteJoint_SetMaxMotorTorque</a></div><div class="ttdeci">B2_API void b2RevoluteJoint_SetMaxMotorTorque(b2JointId jointId, float torque)</div><div class="ttdoc">Set the revolute joint maximum motor torque, usually in newton-meters.</div></div>
<div class="ttc" id="agroup__revolute__joint_html_gac8fd7b3546882fdda79777dd1127aa4e"><div class="ttname"><a href="group__revolute__joint.html#gac8fd7b3546882fdda79777dd1127aa4e">b2RevoluteJoint_SetMotorSpeed</a></div><div class="ttdeci">B2_API void b2RevoluteJoint_SetMotorSpeed(b2JointId jointId, float motorSpeed)</div><div class="ttdoc">Set the revolute joint motor speed in radians per second.</div></div>
</div><!-- fragment --><p>Joint motors have some interesting abilities. You can update the joint speed every time step so you can make the joint move back-and-forth like a sine-wave or according to whatever function you want.</p>
<div class="fragment"><div class="line"><span class="comment">// ... Game Loop Begin ...</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group__revolute__joint.html#gac8fd7b3546882fdda79777dd1127aa4e">b2RevoluteJoint_SetMotorSpeed</a>(myJointId, cosf(0.5f * time));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... Game Loop End ...</span></div>
</div><!-- fragment --><p>You can also use joint motors to track a desired joint angle. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// ... Game Loop Begin ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span> angleError = <a class="code hl_function" href="group__revolute__joint.html#gaaf79f90413f31b0ddbdbb29094a666ea">b2RevoluteJoint_GetAngle</a>(myJointId) - angleTarget;</div>
<div class="line"><span class="keywordtype">float</span> gain = 0.1f;</div>
<div class="line"><a class="code hl_function" href="group__revolute__joint.html#gac8fd7b3546882fdda79777dd1127aa4e">b2RevoluteJoint_SetMotorSpeed</a>(myJointId, -gain * angleError);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... Game Loop End ...</span></div>
</div><!-- fragment --><p>Generally your gain parameter should not be too large. Otherwise your joint may become unstable.</p>
<h2><a class="anchor" id="autotoc_md108"></a>
Prismatic Joint</h2>
<p>A prismatic joint allows for relative translation of two bodies along a local axis. A prismatic joint prevents relative rotation. Therefore, a prismatic joint has a single degree of freedom.</p>
<div class="image">
<object type="image/svg+xml" data="prismatic_joint.svg" style="pointer-events: none;"></object>
<div class="caption">
Prismatic Joint</div></div>
    <p>The prismatic joint definition is similar to the revolute joint description; just substitute translation for angle and force for torque. Using this analogy provides an example prismatic joint definition with a joint limit and a friction motor:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> worldPivot = {10.0f, -4.0f};</div>
<div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> worldAxis = {1.0f, 0.0f};</div>
<div class="line"><a class="code hl_struct" href="group__prismatic__joint.html#structb2_prismatic_joint_def">b2PrismaticJointDef</a> jointDef = b2DefaultPrismaticJointDef();</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__prismatic__joint.html#a6b24ca88149656eef773a58b312c6cf5">bodyIdA</a> = myBodyIdA;</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__prismatic__joint.html#ad58efba00755786b06b11d66522128fc">bodyIdB</a> = myBodyIdB;</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__prismatic__joint.html#abb51df8daff7a55f47adc83e4f7fa5b9">localAnchorA</a> = <a class="code hl_function" href="group__body.html#gac10f227ccd433b997fe8158d0724f5b9">b2Body_GetLocalPoint</a>(myBodyIdA, worldPivot);</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__prismatic__joint.html#a5acc1f2f14d1b659fc9d804ab1baf4a3">localAnchorB</a> = <a class="code hl_function" href="group__body.html#gac10f227ccd433b997fe8158d0724f5b9">b2Body_GetLocalPoint</a>(myBodyIdB, worldPivot);</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__prismatic__joint.html#af36fdbcedca5a392a2649cd235c42676">localAxisA</a> = <a class="code hl_function" href="group__body.html#ga983ef6f5815a611bbe6327f4ec7308b9">b2Body_GetLocalVector</a>(myBodyIdA, worldAxis);</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__prismatic__joint.html#a4ad5f83296c7be60f1b0ecd5a442f8dc">lowerTranslation</a> = -5.0f;</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__prismatic__joint.html#a7606811782ccef96beeccbc0b56eaf34">upperTranslation</a> = 2.5f;</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__prismatic__joint.html#aa61a03b68caac62a5cf66354f6756eae">enableLimit</a> = <span class="keyword">true</span>;</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__prismatic__joint.html#af7bb74b4f5188352c704d9822fb20d5a">maxMotorForce</a> = 1.0f;</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__prismatic__joint.html#a58c40902a70a31bf4f6e17f3d4c7413a">motorSpeed</a> = 0.0f;</div>
<div class="line">jointDef.<a class="code hl_variable" href="group__prismatic__joint.html#a58ac79a54a8110d3a745e1d6d36990dc">enableMotor</a> = <span class="keyword">true</span>;</div>
<div class="ttc" id="agroup__prismatic__joint_html_a4ad5f83296c7be60f1b0ecd5a442f8dc"><div class="ttname"><a href="group__prismatic__joint.html#a4ad5f83296c7be60f1b0ecd5a442f8dc">b2PrismaticJointDef::lowerTranslation</a></div><div class="ttdeci">float lowerTranslation</div><div class="ttdoc">The lower translation limit.</div><div class="ttdef"><b>Definition</b> types.h:739</div></div>
<div class="ttc" id="agroup__prismatic__joint_html_a58ac79a54a8110d3a745e1d6d36990dc"><div class="ttname"><a href="group__prismatic__joint.html#a58ac79a54a8110d3a745e1d6d36990dc">b2PrismaticJointDef::enableMotor</a></div><div class="ttdeci">bool enableMotor</div><div class="ttdoc">Enable/disable the joint motor.</div><div class="ttdef"><b>Definition</b> types.h:745</div></div>
<div class="ttc" id="agroup__prismatic__joint_html_a58c40902a70a31bf4f6e17f3d4c7413a"><div class="ttname"><a href="group__prismatic__joint.html#a58c40902a70a31bf4f6e17f3d4c7413a">b2PrismaticJointDef::motorSpeed</a></div><div class="ttdeci">float motorSpeed</div><div class="ttdoc">The desired motor speed, typically in meters per second.</div><div class="ttdef"><b>Definition</b> types.h:751</div></div>
<div class="ttc" id="agroup__prismatic__joint_html_a5acc1f2f14d1b659fc9d804ab1baf4a3"><div class="ttname"><a href="group__prismatic__joint.html#a5acc1f2f14d1b659fc9d804ab1baf4a3">b2PrismaticJointDef::localAnchorB</a></div><div class="ttdeci">b2Vec2 localAnchorB</div><div class="ttdoc">The local anchor point relative to bodyB&#39;s origin.</div><div class="ttdef"><b>Definition</b> types.h:718</div></div>
<div class="ttc" id="agroup__prismatic__joint_html_a6b24ca88149656eef773a58b312c6cf5"><div class="ttname"><a href="group__prismatic__joint.html#a6b24ca88149656eef773a58b312c6cf5">b2PrismaticJointDef::bodyIdA</a></div><div class="ttdeci">b2BodyId bodyIdA</div><div class="ttdoc">The first attached body.</div><div class="ttdef"><b>Definition</b> types.h:709</div></div>
<div class="ttc" id="agroup__prismatic__joint_html_a7606811782ccef96beeccbc0b56eaf34"><div class="ttname"><a href="group__prismatic__joint.html#a7606811782ccef96beeccbc0b56eaf34">b2PrismaticJointDef::upperTranslation</a></div><div class="ttdeci">float upperTranslation</div><div class="ttdoc">The upper translation limit.</div><div class="ttdef"><b>Definition</b> types.h:742</div></div>
<div class="ttc" id="agroup__prismatic__joint_html_aa61a03b68caac62a5cf66354f6756eae"><div class="ttname"><a href="group__prismatic__joint.html#aa61a03b68caac62a5cf66354f6756eae">b2PrismaticJointDef::enableLimit</a></div><div class="ttdeci">bool enableLimit</div><div class="ttdoc">Enable/disable the joint limit.</div><div class="ttdef"><b>Definition</b> types.h:736</div></div>
<div class="ttc" id="agroup__prismatic__joint_html_abb51df8daff7a55f47adc83e4f7fa5b9"><div class="ttname"><a href="group__prismatic__joint.html#abb51df8daff7a55f47adc83e4f7fa5b9">b2PrismaticJointDef::localAnchorA</a></div><div class="ttdeci">b2Vec2 localAnchorA</div><div class="ttdoc">The local anchor point relative to bodyA&#39;s origin.</div><div class="ttdef"><b>Definition</b> types.h:715</div></div>
<div class="ttc" id="agroup__prismatic__joint_html_ad58efba00755786b06b11d66522128fc"><div class="ttname"><a href="group__prismatic__joint.html#ad58efba00755786b06b11d66522128fc">b2PrismaticJointDef::bodyIdB</a></div><div class="ttdeci">b2BodyId bodyIdB</div><div class="ttdoc">The second attached body.</div><div class="ttdef"><b>Definition</b> types.h:712</div></div>
<div class="ttc" id="agroup__prismatic__joint_html_af36fdbcedca5a392a2649cd235c42676"><div class="ttname"><a href="group__prismatic__joint.html#af36fdbcedca5a392a2649cd235c42676">b2PrismaticJointDef::localAxisA</a></div><div class="ttdeci">b2Vec2 localAxisA</div><div class="ttdoc">The local translation unit axis in bodyA.</div><div class="ttdef"><b>Definition</b> types.h:721</div></div>
<div class="ttc" id="agroup__prismatic__joint_html_af7bb74b4f5188352c704d9822fb20d5a"><div class="ttname"><a href="group__prismatic__joint.html#af7bb74b4f5188352c704d9822fb20d5a">b2PrismaticJointDef::maxMotorForce</a></div><div class="ttdeci">float maxMotorForce</div><div class="ttdoc">The maximum motor force, typically in newtons.</div><div class="ttdef"><b>Definition</b> types.h:748</div></div>
<div class="ttc" id="agroup__prismatic__joint_html_structb2_prismatic_joint_def"><div class="ttname"><a href="group__prismatic__joint.html#structb2_prismatic_joint_def">b2PrismaticJointDef</a></div><div class="ttdoc">Prismatic joint definition.</div><div class="ttdef"><b>Definition</b> types.h:707</div></div>
</div><!-- fragment --><p>The revolute joint has an implicit axis coming out of the screen. The prismatic joint needs an explicit axis parallel to the screen. This axis is fixed in body A.</p>
<p>The prismatic joint translation is zero when the anchor points overlap. I recommend to have the prismatic anchor points close to the center of mass of the two bodies. This will improve joint stiffness.</p>
<p>Using a prismatic joint is similar to using a revolute joint. Here are the relevant member functions:</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> PrismaticJoint::GetJointTranslation() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">float</span> PrismaticJoint::GetJointSpeed() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">float</span> PrismaticJoint::GetMotorForce() <span class="keyword">const</span>;</div>
<div class="line"><span class="keywordtype">void</span> PrismaticJoint::SetMotorSpeed(<span class="keywordtype">float</span> speed);</div>
<div class="line"><span class="keywordtype">void</span> PrismaticJoint::SetMotorForce(<span class="keywordtype">float</span> force);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md109"></a>
Mouse Joint</h2>
<p>The mouse joint is used in the samples to manipulate bodies with the mouse. It attempts to drive a point on a body towards the current position of the cursor. There is no restriction on rotation.</p>
<p>The mouse joint definition has a target point, maximum force, Hertz, and damping ratio. The target point initially coincides with the body's anchor point. The maximum force is used to prevent violent reactions when multiple dynamic bodies interact. You can make this as large as you like. The frequency and damping ratio are used to create a spring/damper effect similar to the distance joint.</p>
<h2><a class="anchor" id="autotoc_md110"></a>
Weld Joint</h2>
<p>The weld joint attempts to constrain all relative motion between two bodies. See the <code>Cantilever</code> sample to see how the weld joint behaves.</p>
<p>It is tempting to use the weld joint to define breakable structures. However, the Box2D solver is approximate so the joints can be soft in some cases regardless of the joint settings. So chains of bodies connected by weld joints may flex.</p>
<p>See the <code>ContactEvent</code> sample for an example of how to merge and split bodies without using the weld joint.</p>
<h2><a class="anchor" id="autotoc_md111"></a>
Motor Joint</h2>
<p>A motor joint lets you control the motion of a body by specifying target position and rotation offsets. You can set the maximum motor force and torque that will be applied to reach the target position and rotation. If the body is blocked, it will stop and the contact forces will be proportional the maximum motor force and torque. See <code><a class="el" href="group__motor__joint.html#structb2_motor_joint_def" title="A motor joint is used to control the relative motion between two bodies.">b2MotorJointDef</a></code> and the <code>MotorJoint</code> sample for details.</p>
<h2><a class="anchor" id="autotoc_md112"></a>
Wheel Joint</h2>
<p>The wheel joint restricts a point on bodyB to a line on bodyA. The wheel joint also provides a suspension spring and a motor. See the <code>Driving</code> sample for details.</p>
<div class="image">
<object type="image/svg+xml" data="wheel_joint.svg" style="pointer-events: none;"></object>
<div class="caption">
Wheel Joint</div></div>
    <p>The wheel joint is designed specifically for vehicles. It provides a translation and rotation. The translation has a spring and damper to simulate the vehicle suspension. The rotation allows the wheel to rotate. You can specify an rotational motor to drive the wheel and to apply braking. See <code><a class="el" href="group__wheel__joint.html#structb2_wheel_joint_def" title="Wheel joint definition.">b2WheelJointDef</a></code> and the <code>Drive</code> sample for details.</p>
<p>You may also use the wheel joint where you want free rotation and translation along an axis. See the <code>ScissorLift</code> sample for details.</p>
<h1><a class="anchor" id="spatial"></a>
Spatial Queries</h1>
<p>Spatial queries allow you to inspect the world geometrically. There are overlap queries, ray-casts, and shape-casts. These allow you to do things like:</p><ul>
<li>find a treasure chest near the player</li>
<li>shoot a laser beam and destroy all asteroids in the path</li>
<li>throw a grenade that is represented as a circle moving along a parabolic path</li>
</ul>
<h2><a class="anchor" id="autotoc_md113"></a>
Overlap Queries</h2>
<p>Sometimes you want to determine all the shapes in a region. The world has a fast log(N) method for this using the broad-phase data structure. Box2D provides these overlap tests:</p><ul>
<li>axis-aligned bound box (AABB) overlap</li>
<li>shape proxy overlap</li>
</ul>
<h3><a class="anchor" id="autotoc_md114"></a>
Query Filtering</h3>
<p>A basic understanding of query filtering is needed before considering the specific queries. Shape versus shape filtering was discussed <a class="el" href="#filtering">here</a>. A similar setup is used for queries. This lets your queries only consider certain categories of shapes, it also lets your shapes ignore certain queries.</p>
<p>Just like shapes, queries themselves can have a category. For example, you can have a <code>CAMERA</code> or <code>PROJECTILE</code> category.</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> MyCategories</div>
<div class="line">{</div>
<div class="line">    STATIC = 0x00000001,</div>
<div class="line">    PLAYER = 0x00000002,</div>
<div class="line">    MONSTER = 0x00000004,</div>
<div class="line">    WINDOW = 0x00000008,</div>
<div class="line">    CAMERA = 0x00000010,</div>
<div class="line">    PROJECTILE = 0x00000020,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Grenades collide with the static world, monsters, and windows but</span></div>
<div class="line"><span class="comment">// not players or other projectiles.</span></div>
<div class="line"><a class="code hl_struct" href="group__shape.html#structb2_query_filter">b2QueryFilter</a> grenadeFilter;</div>
<div class="line">grenadeFilter.<a class="code hl_variable" href="group__shape.html#ae6ab473dc0dd363830394c899a50bbde">categoryBits</a> = PROJECTILE;</div>
<div class="line">grenadeFilter.<a class="code hl_variable" href="group__shape.html#a4ba3fd17260e8f406f993ffd524c9879">maskBits</a> = STATIC | MONSTER | WINDOW;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The view collides with the static world, monsters, and players.</span></div>
<div class="line"><a class="code hl_struct" href="group__shape.html#structb2_query_filter">b2QueryFilter</a> viewFilter;</div>
<div class="line">viewFilter.<a class="code hl_variable" href="group__shape.html#ae6ab473dc0dd363830394c899a50bbde">categoryBits</a> = CAMERA;</div>
<div class="line">viewFilter.<a class="code hl_variable" href="group__shape.html#a4ba3fd17260e8f406f993ffd524c9879">maskBits</a> = STATIC | PLAYER | MONSTER;</div>
<div class="ttc" id="agroup__shape_html_a4ba3fd17260e8f406f993ffd524c9879"><div class="ttname"><a href="group__shape.html#a4ba3fd17260e8f406f993ffd524c9879">b2QueryFilter::maskBits</a></div><div class="ttdeci">uint64_t maskBits</div><div class="ttdoc">The collision mask bits.</div><div class="ttdef"><b>Definition</b> types.h:303</div></div>
<div class="ttc" id="agroup__shape_html_ae6ab473dc0dd363830394c899a50bbde"><div class="ttname"><a href="group__shape.html#ae6ab473dc0dd363830394c899a50bbde">b2QueryFilter::categoryBits</a></div><div class="ttdeci">uint64_t categoryBits</div><div class="ttdoc">The collision category bits of this query. Normally you would just set one bit.</div><div class="ttdef"><b>Definition</b> types.h:299</div></div>
<div class="ttc" id="agroup__shape_html_structb2_query_filter"><div class="ttname"><a href="group__shape.html#structb2_query_filter">b2QueryFilter</a></div><div class="ttdoc">The query filter is used to filter collisions between queries and shapes.</div><div class="ttdef"><b>Definition</b> types.h:297</div></div>
</div><!-- fragment --><p>If you want to query everything you can use <code><a class="el" href="group__shape.html#ga34154542665f8a8d4a8cb2eb94334e6d" title="Use this to initialize your query filter.">b2DefaultQueryFilter()</a></code>;</p>
<h3><a class="anchor" id="autotoc_md115"></a>
AABB Overlap</h3>
<p>You provide an AABB in world coordinates and an implementation of <code><a class="el" href="group__world.html#ga1d93e3d04057bd9673689e7e27f6a7d3" title="Prototype callback for overlap queries.">b2OverlapResultFcn()</a></code>. The world calls your function with each shape whose AABB overlaps the query AABB. Return true to continue the query, otherwise return false. For example, the following code finds all the shapes that potentially intersect a specified AABB and wakes up all of the associated bodies.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> MyOverlapCallback(<a class="code hl_struct" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeId, <span class="keywordtype">void</span>* context)</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="group__id.html#structb2_body_id">b2BodyId</a> bodyId = <a class="code hl_function" href="group__shape.html#ga7d3fe672434ba971c2d5f172c9b9d465">b2Shape_GetBody</a>(shapeId);</div>
<div class="line">    <a class="code hl_function" href="group__body.html#ga401edc0fdbe6945a9393e1a90af0d3db">b2Body_SetAwake</a>(bodyId, <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Return true to continue the query.</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Elsewhere ...</span></div>
<div class="line">MyOverlapCallback callback;</div>
<div class="line"><a class="code hl_struct" href="group__math.html#structb2_a_a_b_b">b2AABB</a> aabb;</div>
<div class="line">aabb.lowerBound = (<a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a>){-1.0f, -1.0f};</div>
<div class="line">aabb.upperBound = (<a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a>){1.0f, 1.0f};</div>
<div class="line"><a class="code hl_struct" href="group__shape.html#structb2_query_filter">b2QueryFilter</a> filter = <a class="code hl_function" href="group__shape.html#ga34154542665f8a8d4a8cb2eb94334e6d">b2DefaultQueryFilter</a>();</div>
<div class="line"><a class="code hl_function" href="group__world.html#gad454cfcf6b30dc5ad83b849ef04e4505">b2World_OverlapAABB</a>(myWorldId, aabb, filter, MyOverlapCallback, &amp;myGame);</div>
<div class="ttc" id="agroup__math_html_structb2_a_a_b_b"><div class="ttname"><a href="group__math.html#structb2_a_a_b_b">b2AABB</a></div><div class="ttdoc">Axis-aligned bounding box.</div><div class="ttdef"><b>Definition</b> math_functions.h:59</div></div>
<div class="ttc" id="agroup__shape_html_ga34154542665f8a8d4a8cb2eb94334e6d"><div class="ttname"><a href="group__shape.html#ga34154542665f8a8d4a8cb2eb94334e6d">b2DefaultQueryFilter</a></div><div class="ttdeci">b2QueryFilter b2DefaultQueryFilter(void)</div><div class="ttdoc">Use this to initialize your query filter.</div></div>
<div class="ttc" id="agroup__shape_html_ga7d3fe672434ba971c2d5f172c9b9d465"><div class="ttname"><a href="group__shape.html#ga7d3fe672434ba971c2d5f172c9b9d465">b2Shape_GetBody</a></div><div class="ttdeci">B2_API b2BodyId b2Shape_GetBody(b2ShapeId shapeId)</div><div class="ttdoc">Get the id of the body that a shape is attached to.</div></div>
<div class="ttc" id="agroup__world_html_gad454cfcf6b30dc5ad83b849ef04e4505"><div class="ttname"><a href="group__world.html#gad454cfcf6b30dc5ad83b849ef04e4505">b2World_OverlapAABB</a></div><div class="ttdeci">B2_API b2TreeStats b2World_OverlapAABB(b2WorldId worldId, b2AABB aabb, b2QueryFilter filter, b2OverlapResultFcn *fcn, void *context)</div><div class="ttdoc">Overlap test for all shapes that potentially overlap the provided AABB.</div></div>
</div><!-- fragment --><p>Do not make any assumptions about the order of the callback. The order shapes are returned to your callback may seem arbitrary.</p>
<h3><a class="anchor" id="autotoc_md116"></a>
Shape Overlap</h3>
<p>The AABB overlap is very fast but not very accurate because it only considers the shape bounding box. If you want an accurate overlap test, you can use a shape overlap query.</p>
<p>The overlap function uses a <code><a class="el" href="group__geometry.html#structb2_shape_proxy" title="A distance proxy is used by the GJK algorithm.">b2ShapeProxy</a></code> which is an abstract shape consisting of some points and a radius. You can think of it as a cloud of circles that has been <em>shrink wrapped</em>. This can represent a point, a circle, a line segment, a capsule, a polygon, a rounded rectangle, and so on. The helper function <code>b2MakeProxy</code> takes an array of points and a radius.</p>
<p>In this example, I'm creating a shape proxy from a circle and then calling <code><a class="el" href="group__world.html#gaef5c2305dc03953f165835a832e7425c" title="Overlap test for all shapes that overlap the provided shape proxy.">b2World_OverlapShape()</a></code>. This takes a <code><a class="el" href="group__world.html#ga1d93e3d04057bd9673689e7e27f6a7d3" title="Prototype callback for overlap queries.">b2OverlapResultFcn()</a></code> to receive results and control the search progress.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_circle">b2Circle</a> circle = {b2Vec2_zero, 0.2f};</div>
<div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_shape_proxy">b2ShapeProxy</a> proxy = <a class="code hl_function" href="group__distance.html#ga6f8ad971653ec8d13e7f8666b9f8e3bb">b2MakeProxy</a>(&amp;circle.<a class="code hl_variable" href="group__geometry.html#aa919960819f321a014ef46beafe2e3d0">center</a>, 1, circle.<a class="code hl_variable" href="group__geometry.html#a757d579fa23bd9090a1f5c52c37703ad">radius</a>);</div>
<div class="line"><a class="code hl_function" href="group__world.html#gaef5c2305dc03953f165835a832e7425c">b2World_OverlapShape</a>(myWorldId, &amp;proxy, grenadeFilter, MyOverlapCallback, &amp;myGame);</div>
<div class="ttc" id="agroup__distance_html_ga6f8ad971653ec8d13e7f8666b9f8e3bb"><div class="ttname"><a href="group__distance.html#ga6f8ad971653ec8d13e7f8666b9f8e3bb">b2MakeProxy</a></div><div class="ttdeci">b2ShapeProxy b2MakeProxy(const b2Vec2 *points, int count, float radius)</div><div class="ttdoc">Make a proxy for use in overlap, shape cast, and related functions. This is a deep copy of the points...</div></div>
<div class="ttc" id="agroup__geometry_html_a757d579fa23bd9090a1f5c52c37703ad"><div class="ttname"><a href="group__geometry.html#a757d579fa23bd9090a1f5c52c37703ad">b2Circle::radius</a></div><div class="ttdeci">float radius</div><div class="ttdoc">The radius.</div><div class="ttdef"><b>Definition</b> collision.h:110</div></div>
<div class="ttc" id="agroup__geometry_html_aa919960819f321a014ef46beafe2e3d0"><div class="ttname"><a href="group__geometry.html#aa919960819f321a014ef46beafe2e3d0">b2Circle::center</a></div><div class="ttdeci">b2Vec2 center</div><div class="ttdoc">The local center.</div><div class="ttdef"><b>Definition</b> collision.h:107</div></div>
<div class="ttc" id="agroup__geometry_html_structb2_circle"><div class="ttname"><a href="group__geometry.html#structb2_circle">b2Circle</a></div><div class="ttdoc">A solid circle.</div><div class="ttdef"><b>Definition</b> collision.h:105</div></div>
<div class="ttc" id="agroup__geometry_html_structb2_shape_proxy"><div class="ttname"><a href="group__geometry.html#structb2_shape_proxy">b2ShapeProxy</a></div><div class="ttdoc">A distance proxy is used by the GJK algorithm.</div><div class="ttdef"><b>Definition</b> collision.h:42</div></div>
<div class="ttc" id="agroup__world_html_gaef5c2305dc03953f165835a832e7425c"><div class="ttname"><a href="group__world.html#gaef5c2305dc03953f165835a832e7425c">b2World_OverlapShape</a></div><div class="ttdeci">B2_API b2TreeStats b2World_OverlapShape(b2WorldId worldId, const b2ShapeProxy *proxy, b2QueryFilter filter, b2OverlapResultFcn *fcn, void *context)</div><div class="ttdoc">Overlap test for all shapes that overlap the provided shape proxy.</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md117"></a>
Ray-casts</h2>
<p>You can use ray-casts to do line-of-sight checks, fire guns, etc. You perform a ray-cast by implementing the <code><a class="el" href="group__world.html#gad34f863cfebe93a7d6448c30e30f6a01" title="Prototype callback for ray casts.">b2CastResultFcn()</a></code> callback function and providing the origin point and translation. The world calls your function with each shape hit by the ray. Your callback is provided with the shape, the point of intersection, the unit normal vector, and the fractional distance along the ray. You cannot make any assumptions about the order of the points sent to the callback. The callback may receive points that are further away before receiving points that are closer.</p>
<p>You control the continuation of the ray-cast by returning a fraction. Returning a fraction of zero indicates the ray-cast should be terminated. A fraction of one indicates the ray-cast should continue as if no hit occurred. If you return the fraction from the argument list, the ray will be clipped to the current intersection point. So you can ray-cast any shape, ray-cast all shapes, or ray-cast the closest shape by returning the appropriate fraction.</p>
<p>You may also return of fraction of -1 to filter the shape. Then the ray-cast will proceed as if the shape does not exist.</p>
<p>Here is an example:</p>
<div class="fragment"><div class="line"><span class="comment">// This struct captures the closest hit shape</span></div>
<div class="line"><span class="keyword">struct </span>MyRayCastContext</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeId;</div>
<div class="line">    <a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> point;</div>
<div class="line">    <a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> normal;</div>
<div class="line">    <span class="keywordtype">float</span> fraction;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span> MyCastCallback(<a class="code hl_struct" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeId, <a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> point, <a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> normal, <span class="keywordtype">float</span> fraction, <span class="keywordtype">void</span>* context)</div>
<div class="line">{</div>
<div class="line">    MyRayCastContext* myContext = context;</div>
<div class="line">    myContext-&gt;shape = shape;</div>
<div class="line">    myContext-&gt;point = point;</div>
<div class="line">    myContext-&gt;normal = normal;</div>
<div class="line">    myContext-&gt;fraction = fraction;</div>
<div class="line">    <span class="keywordflow">return</span> fraction;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Elsewhere ...</span></div>
<div class="line">MyRayCastContext context = {0};</div>
<div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> origin = {-1.0f, 0.0f};</div>
<div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> end(3.0f, 1.0f);</div>
<div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> translation = <a class="code hl_function" href="group__math.html#ga8d998480421a61c83d81d7da1820cc60">b2Sub</a>(end, origin);</div>
<div class="line"><a class="code hl_function" href="group__world.html#gae07f3efd22833954040c9fe681de0ff9">b2World_CastRay</a>(myWorldId, origin, translation, viewFilter, MyCastCallback, &amp;context);</div>
<div class="ttc" id="agroup__math_html_ga8d998480421a61c83d81d7da1820cc60"><div class="ttname"><a href="group__math.html#ga8d998480421a61c83d81d7da1820cc60">b2Sub</a></div><div class="ttdeci">b2Vec2 b2Sub(b2Vec2 a, b2Vec2 b)</div><div class="ttdoc">Vector subtraction.</div><div class="ttdef"><b>Definition</b> math_functions.h:187</div></div>
<div class="ttc" id="agroup__world_html_gae07f3efd22833954040c9fe681de0ff9"><div class="ttname"><a href="group__world.html#gae07f3efd22833954040c9fe681de0ff9">b2World_CastRay</a></div><div class="ttdeci">B2_API b2TreeStats b2World_CastRay(b2WorldId worldId, b2Vec2 origin, b2Vec2 translation, b2QueryFilter filter, b2CastResultFcn *fcn, void *context)</div><div class="ttdoc">Cast a ray into the world to collect shapes in the path of the ray.</div></div>
</div><!-- fragment --><p>Ray-cast results may be delivered in an arbitrary order. This doesn't affect the result for closest point ray-casts (except in ties). When you are collecting multiple hits along the ray, you may want to sort them according to the hit fraction. See the <code>CastWorld</code> sample for details.</p>
<h2><a class="anchor" id="autotoc_md118"></a>
Shape-casts</h2>
<p>Shape-casts are similar to ray-casts. You can view a ray-cast as tracing a point along a line. A shape-cast allows you to trace a shape along a line. Like the shape overlap query, the shape cast uses a <code><a class="el" href="group__geometry.html#structb2_shape_proxy" title="A distance proxy is used by the GJK algorithm.">b2ShapeProxy</a></code> to represent an arbitrary shape.</p>
<div class="fragment"><div class="line"><span class="comment">// This struct captures the closest hit shape</span></div>
<div class="line"><span class="keyword">struct </span>MyRayCastContext</div>
<div class="line">{</div>
<div class="line">    <a class="code hl_struct" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeId;</div>
<div class="line">    <a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> point;</div>
<div class="line">    <a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> normal;</div>
<div class="line">    <span class="keywordtype">float</span> fraction;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span> MyCastCallback(<a class="code hl_struct" href="group__id.html#structb2_shape_id">b2ShapeId</a> shapeId, <a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> point, <a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> normal, <span class="keywordtype">float</span> fraction, <span class="keywordtype">void</span>* context)</div>
<div class="line">{</div>
<div class="line">    MyRayCastContext* myContext = context;</div>
<div class="line">    myContext-&gt;shape = shape;</div>
<div class="line">    myContext-&gt;point = point;</div>
<div class="line">    myContext-&gt;normal = normal;</div>
<div class="line">    myContext-&gt;fraction = fraction;</div>
<div class="line">    <span class="keywordflow">return</span> fraction;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Elsewhere ...</span></div>
<div class="line">MyRayCastContext context = {0};</div>
<div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_circle">b2Circle</a> circle = {{-1.0f, 0.0f}, 0.05f};</div>
<div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_shape_proxy">b2ShapeProxy</a> proxy = <a class="code hl_function" href="group__distance.html#ga6f8ad971653ec8d13e7f8666b9f8e3bb">b2MakeProxy</a>(&amp;circle.<a class="code hl_variable" href="group__geometry.html#aa919960819f321a014ef46beafe2e3d0">center</a>, 1, circle.<a class="code hl_variable" href="group__geometry.html#a757d579fa23bd9090a1f5c52c37703ad">radius</a>);</div>
<div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> translation = {10.0f, -5.0f};</div>
<div class="line">b2World_CastCircle(myWorldId, &amp;proxy, translation, grenadeFilter, MyCastCallback, &amp;context);</div>
</div><!-- fragment --><p>Otherwise, shape-casts are setup similarly to ray-casts. You can expect shape-casts to generally be slower than ray-casts. So only use a shape-cast if a ray-cast won't do.</p>
<p>Just like ray-casts, shape-casts results may be sent to the callback in any order. If you need multiple sorted results, you will need to write some code to collect and sort the results.</p>
<h1><a class="anchor" id="autotoc_md119"></a>
Simulation Loop</h1>
<div class="image">
<object type="image/svg+xml" data="simulation_loop.svg" style="pointer-events: none;"></object>
<div class="caption">
Simulation Loop</div></div>
    <p>The Box2D simulation loop can be useful to understand when you process results.</p>
<p>Multithreading is represented in the diagram.</p><ul>
<li>rectangles are parallel-for work</li>
<li>rounded rectangles are single-threaded work, but may be in parallel with other work</li>
</ul>
<p>Let's review each of these stages.</p>
<h2><a class="anchor" id="autotoc_md120"></a>
time step</h2>
<p>The game starts the simulation by calling <code>b2World_Step</code> supplying the time step.</p>
<h2><a class="anchor" id="autotoc_md121"></a>
find pairs</h2>
<p>Box2D maintains a record of every shape that has moved. For each of these shapes the broad-phase (BVH) is queried for overlaps. New overlaps are recorded for processing in the next step. I avoid reporting existing overlaps by using a hash table that records all existing shape pairs. This operation is a parallel-for.</p>
<h2><a class="anchor" id="autotoc_md122"></a>
create contacts</h2>
<p>This takes the pair results and creates the internal contact pair structure (<code>b2Contact</code>). This structure is persistent across time steps. It is used for the island graph and holding contact manifolds. This operation is single-threaded but most of the work is done in <code>find pairs</code>.</p>
<h2><a class="anchor" id="autotoc_md123"></a>
rebuild BVH</h2>
<p>After the new shape pairs are known the BVH is not considered until later in the time step. Therefore the BVH for dynamic and kinematic shapes may be optimized. This involves identifying the part of the collision tree that is stale from refitting and then performing a rebuild of that sub-tree. This is a single-single threaded operation that is done concurrently with other work.</p>
<h2><a class="anchor" id="autotoc_md124"></a>
narrow phase</h2>
<p>This is where the contact manifolds and points are computed. Each active contact pair is confirmed as touching or non-touching. If the touching state changes then contact begin and end events are generated. This is a parallel-for operation.</p>
<p>Notice that contact points are computed at the beginning of the time step, before bodies have moved and before impulses are known. This is necessary for obtaining good simulation results efficiently. If contacts were computed at the end of the time step then new contact points would not be known to the constraint solver and shapes would sink into each other.</p>
<p>The <code><a class="el" href="group__world.html#gabc67e8e35069f7fc50755006ae5b4bab" title="Prototype for a pre-solve callback.">b2PreSolveFcn</a></code> is called within the parallel-for so it should be efficient and thread-safe. This is only called for shapes that have <code>enablePreSolveEvents == true</code>.</p>
<h2><a class="anchor" id="autotoc_md125"></a>
merge islands</h2>
<p>Simulation islands are merged when shapes begin touching. Existing islands that have shapes that stop touching are flagged as candidates for splitting. This stage is single-threaded.</p>
<h2><a class="anchor" id="autotoc_md126"></a>
split island</h2>
<p>A split island task may be generated if:</p><ul>
<li>there is an island that has shapes that stopped touching</li>
<li>this island has a body that is moving slow enough to sleep Splitting an island may result in several new islands being created. Only a single island will be split per time step because it is expensive. Delaying the split may delay some bodies from sleeping. This is a single-single threaded operation that is done concurrently with other work.</li>
</ul>
<h2><a class="anchor" id="autotoc_md127"></a>
solve constraints</h2>
<p>This solves contact and joint constraints and applies restitution. This a parallel-for with multiple internal stages.</p>
<h2><a class="anchor" id="autotoc_md128"></a>
update transforms</h2>
<p>This stage does several tasks:</p><ul>
<li>updates body transforms</li>
<li>updates the body sleeping status</li>
<li>generates body move events</li>
<li>generates island splitting candidates</li>
<li>resets forces and torques</li>
<li>updates shape bounding boxes</li>
<li>performs continuous collision between dynamic and static bodies This stage is parallel-for.</li>
</ul>
<p>Note that continuous collision does not generate events. Instead they are generated the next time step. However, continuous collision will issue a <code><a class="el" href="group__world.html#gabc67e8e35069f7fc50755006ae5b4bab" title="Prototype for a pre-solve callback.">b2PreSolveFcn</a></code> callback.</p>
<h2><a class="anchor" id="autotoc_md129"></a>
hit events</h2>
<p>Active contacts are scanned for fast approach velocities and added to a buffer. This considers contact points that have an impulse. This includes touching contacts and speculative contacts that generated an impulse (they are confirmed). So you may get hit events for contact points that have a positive separation. This is a single-threaded operation.</p>
<h2><a class="anchor" id="autotoc_md130"></a>
refit BVH</h2>
<p>This updates the BVH for shapes that have moved significantly. This is done by enlarging the shapes bounding box and all ancestor bounding boxes in the BVH. This is a single-threaded operation.</p>
<p>This can result in an inefficient BVH. This is the reason for the <code>rebuild BVH</code> stage. Refitting is faster than rebuilding the BVH but is necessary to ensure the BVH is valid for subsequent queries, such as ray casts.</p>
<h2><a class="anchor" id="autotoc_md131"></a>
bullets</h2>
<p>This is where bullets are processed. Not that this comes after hit events because continuous collision in Box2D does not generate events until the next time step.</p>
<h2><a class="anchor" id="autotoc_md132"></a>
island sleep</h2>
<p>When an island goes to sleep the simulation data associated with that island is moved to separate stored. This keeps the active simulation data contiguous and cache friendly.</p>
<h2><a class="anchor" id="autotoc_md133"></a>
sensors</h2>
<p>Sensor overlaps are checked in the final stage. The overlap state reflects the final body transform. Sensors do not consider sleep so they may react to the user setting a body transform or creating a sleeping body. This is a parallel-for operation. The cost is roughly proportional to the number of sensors.</p>
<h1><a class="anchor" id="autotoc_md134"></a>
Determinism</h1>
<p>Box2D is designed to be determinism across thread counts and platforms. I believe this is important for debugging and game design.</p>
<p>Multithreaded determinism is achieved by basing simulation order on creation order. This includes bodies, shapes, and joint creation order. Determinism includes results reported to users (events). These events must be in deterministic order.</p>
<p>Cross-platform determinism is achieved on 64-bit platforms by using compiler flags and by avoiding non-deterministic library functions.</p><ul>
<li>precise math is used on MSVC</li>
<li>floating point contraction is disabled on clang and GCC</li>
<li>Box2D has custom implementations of atan2, cosine, and sine.</li>
</ul>
<p>Determinism is on by default and there is no explicit option to disable it. However, you can break determinism by choosing different compiler flags. Box2D was designed to provide determinism with minimal cost. So there is no advantage to attempting to disable determinism.</p>
<p>I maintain a unit test for determinism that is run for every pull request. Determinism is easy to break, so it is important to have regular validation.</p>
<blockquote class="doxtable">
<p><b>Caution</b>: Box2D determinism does not mean your application will be deterministic. Consider using similar strategies to make your application deterministic as I have used for Box2D. </p>
</blockquote>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
