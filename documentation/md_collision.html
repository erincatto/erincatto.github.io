<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Box2D: Collision</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
window.MathJax = {
  options: {
    ignoreHtmlClass: 'tex2jax_ignore',
    processHtmlClass: 'tex2jax_process'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">Box2D<span id="projectnumber">&#160;3.0.1</span>
   </div>
   <div id="projectbrief">A 2D physics engine for games</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_collision.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Collision</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md31"></a></p>
<p>Box2D provides geometric types and functions. These include:</p><ul>
<li>raw geometry: circles, capsules, segments, and convex polygons</li>
<li>convex hull and related helper functions</li>
<li>mass and bounding box computation</li>
<li>local ray and shape casts</li>
<li>contact manifolds</li>
<li>shape distance</li>
<li>generic shape cast</li>
<li>time of impact</li>
<li>dynamic bounding volume tree</li>
</ul>
<p>The collision interface is designed to be usable outside of rigid body simulation. For example, you can use the dynamic tree for other aspects of your game besides physics.</p>
<p>However, the main purpose of Box2D is to be a rigid body physics engine. So the collision interface only contains features that are also useful in the physics simulation.</p>
<h1><a class="anchor" id="autotoc_md32"></a>
Shape Primitives</h1>
<p>Shape primitives describe collision geometry and may be used independently of physics simulation. At a minimum, you should understand how to create primitives that can be later attached to rigid bodies.</p>
<p>Box2D shape primitives support several operations:</p><ul>
<li>Test a point for overlap with the primitive</li>
<li>Perform a ray cast against the primitive</li>
<li>Compute the primitive's AABB</li>
<li>Compute the mass properties of the primitive</li>
</ul>
<h2><a class="anchor" id="autotoc_md33"></a>
Circles</h2>
<p>Circles have a center and radius. Circles are solid.</p>
<div class="image">
<object type="image/svg+xml" data="circle.svg" style="pointer-events: none;"></object>
<div class="caption">
Circle</div></div>
    <div class="fragment"><div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_circle">b2Circle</a> circle;</div>
<div class="line">circle.<a class="code hl_variable" href="group__geometry.html#aa919960819f321a014ef46beafe2e3d0">center</a> = (<a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a>){2.0f, 3.0f};</div>
<div class="line">circle.<a class="code hl_variable" href="group__geometry.html#a757d579fa23bd9090a1f5c52c37703ad">radius</a> = 0.5f;</div>
<div class="ttc" id="agroup__geometry_html_a757d579fa23bd9090a1f5c52c37703ad"><div class="ttname"><a href="group__geometry.html#a757d579fa23bd9090a1f5c52c37703ad">b2Circle::radius</a></div><div class="ttdeci">float radius</div><div class="ttdoc">The radius.</div><div class="ttdef"><b>Definition</b> collision.h:105</div></div>
<div class="ttc" id="agroup__geometry_html_aa919960819f321a014ef46beafe2e3d0"><div class="ttname"><a href="group__geometry.html#aa919960819f321a014ef46beafe2e3d0">b2Circle::center</a></div><div class="ttdeci">b2Vec2 center</div><div class="ttdoc">The local center.</div><div class="ttdef"><b>Definition</b> collision.h:102</div></div>
<div class="ttc" id="agroup__geometry_html_structb2_circle"><div class="ttname"><a href="group__geometry.html#structb2_circle">b2Circle</a></div><div class="ttdoc">A solid circle.</div><div class="ttdef"><b>Definition</b> collision.h:100</div></div>
<div class="ttc" id="agroup__math_html_structb2_vec2"><div class="ttname"><a href="group__math.html#structb2_vec2">b2Vec2</a></div><div class="ttdoc">2D vector This can be used to represent a point or free vector</div><div class="ttdef"><b>Definition</b> math_functions.h:23</div></div>
</div><!-- fragment --><p>You can also initialize a circle and other structures inline. This is an equivalent circle:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_circle">b2Circle</a> circle = {{2.0f, 3.0f}, 0.5f};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md34"></a>
Capsules</h2>
<p>Capsules have two center points and a radius. The center points are the centers of two semicircles that are connected by a rectangle.</p>
<div class="image">
<object type="image/svg+xml" data="capsule.svg" style="pointer-events: none;"></object>
<div class="caption">
Capsule</div></div>
    <div class="fragment"><div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_capsule">b2Capsule</a> capsule;</div>
<div class="line">capsule.<a class="code hl_variable" href="group__geometry.html#a825009725db4bb7af7da39cb2f9ea766">center1</a> = (<a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a>){1.0f, 1.0f};</div>
<div class="line">capsule.<a class="code hl_variable" href="group__geometry.html#a825009725db4bb7af7da39cb2f9ea766">center1</a> = (<a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a>){2.0f, 3.0f};</div>
<div class="line">capsule.<a class="code hl_variable" href="group__geometry.html#ab3ce676ad6729815f57cbe4ee8e7a9f4">radius</a> = 0.25f;</div>
<div class="ttc" id="agroup__geometry_html_a825009725db4bb7af7da39cb2f9ea766"><div class="ttname"><a href="group__geometry.html#a825009725db4bb7af7da39cb2f9ea766">b2Capsule::center1</a></div><div class="ttdeci">b2Vec2 center1</div><div class="ttdoc">Local center of the first semicircle.</div><div class="ttdef"><b>Definition</b> collision.h:113</div></div>
<div class="ttc" id="agroup__geometry_html_ab3ce676ad6729815f57cbe4ee8e7a9f4"><div class="ttname"><a href="group__geometry.html#ab3ce676ad6729815f57cbe4ee8e7a9f4">b2Capsule::radius</a></div><div class="ttdeci">float radius</div><div class="ttdoc">The radius of the semicircles.</div><div class="ttdef"><b>Definition</b> collision.h:119</div></div>
<div class="ttc" id="agroup__geometry_html_structb2_capsule"><div class="ttname"><a href="group__geometry.html#structb2_capsule">b2Capsule</a></div><div class="ttdoc">A solid capsule can be viewed as two semicircles connected by a rectangle.</div><div class="ttdef"><b>Definition</b> collision.h:111</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md35"></a>
Polygons</h2>
<p>Box2D polygons are solid convex polygons. A polygon is convex when all line segments connecting two points in the interior do not cross any edge of the polygon. Polygons are solid and never hollow. A polygon must have 3 or more vertices.</p>
<div class="image">
<object type="image/svg+xml" data="convex_concave.svg" style="pointer-events: none;"></object>
<div class="caption">
Convex and Concave Polygons</div></div>
    <p>Polygons vertices are stored with a counter clockwise winding (CCW). We must be careful because the notion of CCW is with respect to a right-handed coordinate system with the z-axis pointing out of the plane. This might turn out to be clockwise on your screen, depending on your coordinate system conventions.</p>
<div class="image">
<object type="image/svg+xml" data="winding.svg" style="pointer-events: none;"></object>
<div class="caption">
Polygon Winding Order</div></div>
    <p>The polygon members are public, but you should use initialization functions to create a polygon. The initialization functions create normal vectors and perform validation.</p>
<p>Polygons in Box2D have a maximum of 8 vertices, as controlled by <a class="el" href="group__geometry.html#ga09d71ee1993bee28b5b2e6d893b41884" title="The maximum number of vertices on a convex polygon.">b2_maxPolygonVertices</a>. If you have more complex shapes, I recommend to use multiple polygons.</p>
<p>There are a few ways to create polygons. You can attempt to create them manually, but this is not recommended. Instead there are several functions provided to create them.</p>
<p>For example if you need a square or box you can use these functions:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_polygon">b2Polygon</a> square = <a class="code hl_function" href="group__geometry.html#ga239b5350502f8abb639684b6fb21e4e4">b2MakeSquare</a>(0.5f);</div>
<div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_polygon">b2Polygon</a> box = <a class="code hl_function" href="group__geometry.html#ga9f61df106f05be28e4c66c83a00a0372">b2MakeBox</a>(0.5f, 1.0f);</div>
<div class="ttc" id="agroup__geometry_html_ga239b5350502f8abb639684b6fb21e4e4"><div class="ttname"><a href="group__geometry.html#ga239b5350502f8abb639684b6fb21e4e4">b2MakeSquare</a></div><div class="ttdeci">b2Polygon b2MakeSquare(float h)</div><div class="ttdoc">Make a square polygon, bypassing the need for a convex hull.</div></div>
<div class="ttc" id="agroup__geometry_html_ga9f61df106f05be28e4c66c83a00a0372"><div class="ttname"><a href="group__geometry.html#ga9f61df106f05be28e4c66c83a00a0372">b2MakeBox</a></div><div class="ttdeci">b2Polygon b2MakeBox(float hx, float hy)</div><div class="ttdoc">Make a box (rectangle) polygon, bypassing the need for a convex hull.</div></div>
<div class="ttc" id="agroup__geometry_html_structb2_polygon"><div class="ttname"><a href="group__geometry.html#structb2_polygon">b2Polygon</a></div><div class="ttdoc">A solid convex polygon.</div><div class="ttdef"><b>Definition</b> collision.h:129</div></div>
</div><!-- fragment --><p>The values provided to these functions are <em>extents</em>, which are half-widths or half-heights. This corresponds with circles and capsules using radii instead of diameters.</p>
<p>Box2D also supports rounded polygons. These are convex polygons with a thick rounded skin.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_polygon">b2Polygon</a> roundedBox = <a class="code hl_function" href="group__geometry.html#gaff6f731585c819ca030db9a1008aae1e">b2MakeRoundedBox</a>(0.5f, 1.0f, 0.25f);</div>
<div class="ttc" id="agroup__geometry_html_gaff6f731585c819ca030db9a1008aae1e"><div class="ttname"><a href="group__geometry.html#gaff6f731585c819ca030db9a1008aae1e">b2MakeRoundedBox</a></div><div class="ttdeci">b2Polygon b2MakeRoundedBox(float hx, float hy, float radius)</div><div class="ttdoc">Make a rounded box, bypassing the need for a convex hull.</div></div>
</div><!-- fragment --><p>If you want a box that is not centered on the body origin, you can use an offset box.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> center = {1.0f, 0.0f};</div>
<div class="line"><span class="keywordtype">float</span> angle = <a class="code hl_define" href="group__math.html#ga3f1872f3fc3c46abc809e7f7d467eb6c">b2_pi</a> / 4.0f;</div>
<div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_polygon">b2Polygon</a> offsetBox = <a class="code hl_function" href="group__geometry.html#ga8ed56ceb8b26b09555c3f93dfadc5504">b2MakeOffsetBox</a>(0.5f, 1.0f, center, angle);</div>
<div class="ttc" id="agroup__geometry_html_ga8ed56ceb8b26b09555c3f93dfadc5504"><div class="ttname"><a href="group__geometry.html#ga8ed56ceb8b26b09555c3f93dfadc5504">b2MakeOffsetBox</a></div><div class="ttdeci">b2Polygon b2MakeOffsetBox(float hx, float hy, b2Vec2 center, float angle)</div><div class="ttdoc">Make an offset box, bypassing the need for a convex hull.</div></div>
<div class="ttc" id="agroup__math_html_ga3f1872f3fc3c46abc809e7f7d467eb6c"><div class="ttname"><a href="group__math.html#ga3f1872f3fc3c46abc809e7f7d467eb6c">b2_pi</a></div><div class="ttdeci">#define b2_pi</div><div class="ttdoc">https://en.wikipedia.org/wiki/Pi</div><div class="ttdef"><b>Definition</b> math_functions.h:18</div></div>
</div><!-- fragment --><p>If you want a more general convex polygon, you can compute the hull using <code><a class="el" href="group__geometry.html#ga74371001b4360b744d7cca35a3b18861" title="Compute the convex hull of a set of points.">b2ComputeHull()</a></code>. Then you can create a polygon from the hull. You can make this rounded or not.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> points[] = {{-1.0f, 0.0f}, {1.0f, 0.0f}, {0.0f, 1.0f}};</div>
<div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_hull">b2Hull</a> hull = <a class="code hl_function" href="group__geometry.html#ga74371001b4360b744d7cca35a3b18861">b2ComputeHull</a>(points, 3);</div>
<div class="line"><span class="keywordtype">float</span> radius = 0.1f;</div>
<div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_polygon">b2Polygon</a> roundedTriangle = <a class="code hl_function" href="group__geometry.html#gaabce3498d22a93acd7ad888271d3cbe1">b2MakePolygon</a>(&amp;hull, radius);</div>
<div class="ttc" id="agroup__geometry_html_ga74371001b4360b744d7cca35a3b18861"><div class="ttname"><a href="group__geometry.html#ga74371001b4360b744d7cca35a3b18861">b2ComputeHull</a></div><div class="ttdeci">b2Hull b2ComputeHull(const b2Vec2 *points, int32_t count)</div><div class="ttdoc">Compute the convex hull of a set of points.</div></div>
<div class="ttc" id="agroup__geometry_html_gaabce3498d22a93acd7ad888271d3cbe1"><div class="ttname"><a href="group__geometry.html#gaabce3498d22a93acd7ad888271d3cbe1">b2MakePolygon</a></div><div class="ttdeci">b2Polygon b2MakePolygon(const b2Hull *hull, float radius)</div><div class="ttdoc">Make a convex polygon from a convex hull.</div></div>
<div class="ttc" id="agroup__geometry_html_structb2_hull"><div class="ttname"><a href="group__geometry.html#structb2_hull">b2Hull</a></div><div class="ttdoc">A convex hull.</div><div class="ttdef"><b>Definition</b> collision.h:258</div></div>
</div><!-- fragment --><p>If you have an automatic process for generating convex polygons, you may feed a degenerate set of points to <code><a class="el" href="group__geometry.html#ga74371001b4360b744d7cca35a3b18861" title="Compute the convex hull of a set of points.">b2ComputeHull()</a></code>. You should check that the hull was created successfully before creating the polygon or you will get an assertion.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_hull">b2Hull</a> questionableHull = <a class="code hl_function" href="group__geometry.html#ga74371001b4360b744d7cca35a3b18861">b2ComputeHull</a>(randomPoints, 8);</div>
<div class="line"><span class="keywordflow">if</span> (questionableHull.<a class="code hl_variable" href="group__geometry.html#a6f455648912581ab08d0ecad281a300d">count</a> == 0)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// handle failure</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__geometry_html_a6f455648912581ab08d0ecad281a300d"><div class="ttname"><a href="group__geometry.html#a6f455648912581ab08d0ecad281a300d">b2Hull::count</a></div><div class="ttdeci">int32_t count</div><div class="ttdoc">The number of points.</div><div class="ttdef"><b>Definition</b> collision.h:263</div></div>
</div><!-- fragment --><p>Degenerate points may be coincident and/or collinear. For the hull to be viable, the enclosed area must be sufficiently positive.</p>
<h2><a class="anchor" id="autotoc_md36"></a>
Segments</h2>
<p>Segments are line segments. Segment shapes can collide with circles, capsules, and polygons but not with other line segments. The collision algorithms used by Box2D require that at least one of two colliding shapes has sufficiently positive area. Segment shapes have no area, so segment-segment collision is not possible.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_segment">b2Segment</a> segment1;</div>
<div class="line">segment1.<a class="code hl_variable" href="group__geometry.html#a1e43ae93f9a3ce4aacfd3d4fa124edeb">point1</a> = (<a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a>){0.0f, 0.0f};</div>
<div class="line">segment2.point2 = (<a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a>){1.0f, 0.0f};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// equivalent</span></div>
<div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_segment">b2Segment</a> segment2 = {{0.0f, 0.0f}, {1.0f, 0.0f}};</div>
<div class="ttc" id="agroup__geometry_html_a1e43ae93f9a3ce4aacfd3d4fa124edeb"><div class="ttname"><a href="group__geometry.html#a1e43ae93f9a3ce4aacfd3d4fa124edeb">b2Segment::point1</a></div><div class="ttdeci">b2Vec2 point1</div><div class="ttdoc">The first point.</div><div class="ttdef"><b>Definition</b> collision.h:150</div></div>
<div class="ttc" id="agroup__geometry_html_structb2_segment"><div class="ttname"><a href="group__geometry.html#structb2_segment">b2Segment</a></div><div class="ttdoc">A line segment with two-sided collision.</div><div class="ttdef"><b>Definition</b> collision.h:148</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md37"></a>
Ghost Collisions</h2>
<p>In many cases a game environment is constructed by connecting several segment shapes end-to-end. This can give rise to an unexpected artifact when a polygon slides along the chain of segments. In the figure below there is a box colliding with an internal vertex. These <em>ghost</em> collisions are caused when the polygon collides with an internal vertex generating an internal collision normal.</p>
<div class="image">
<object type="image/svg+xml" data="ghost_collision.svg" width="30%" style="pointer-events: none;"></object>
<div class="caption">
Ghost Collision</div></div>
    <p>If edge1 did not exist this collision would seem fine. With edge1 present, the internal collision seems like a bug. But normally when Box2D collides two shapes, it views them in isolation.</p>
<p><code><a class="el" href="group__geometry.html#structb2_smooth_segment" title="A smooth line segment with one-sided collision.">b2SmoothSegment</a></code> provides a mechanism for eliminating ghost collisions by storing the adjacent <em>ghost</em> vertices. Box2D uses these ghost vertices to prevent internal collisions.</p>
<div class="image">
<object type="image/svg+xml" data="ghost_vertices.svg" width="30%" style="pointer-events: none;"></object>
<div class="caption">
Ghost Vertices</div></div>
    <p>The Box2D algorithm for dealing with ghost collisions only supports one-sided collision. The front face is to the right when looking from the first vertex towards the second vertex. This matches the counter-clockwise winding order used by polygons.</p>
<h2><a class="anchor" id="autotoc_md38"></a>
Smooth segment</h2>
<p>Smooth segments use a concept called <em>ghost vertices</em> that Box2D can use to eliminate ghost collisions.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_smooth_segment">b2SmoothSegment</a> smoothSegment = {0};</div>
<div class="line">smoothSegment.<a class="code hl_variable" href="group__geometry.html#af55c171fd068abfd5dfac18a5fa43d42">ghost1</a> = (<a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a>){1.7f, 0.0f};</div>
<div class="line">smoothSegment.<a class="code hl_variable" href="group__geometry.html#ac325eeb392c204c197e5dae066088a94">segment</a> = (<a class="code hl_struct" href="group__geometry.html#structb2_segment">b2Segment</a>){{1.0f, 0.25f}, {0.0f, 0.0f}};</div>
<div class="line">smoothSegment.<a class="code hl_variable" href="group__geometry.html#a90a2da7a2aebac2a181c3125ed9abe92">ghost2</a> = (<a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a>){-1.7f, 0.4f};</div>
<div class="ttc" id="agroup__geometry_html_a90a2da7a2aebac2a181c3125ed9abe92"><div class="ttname"><a href="group__geometry.html#a90a2da7a2aebac2a181c3125ed9abe92">b2SmoothSegment::ghost2</a></div><div class="ttdeci">b2Vec2 ghost2</div><div class="ttdoc">The head ghost vertex.</div><div class="ttdef"><b>Definition</b> collision.h:168</div></div>
<div class="ttc" id="agroup__geometry_html_ac325eeb392c204c197e5dae066088a94"><div class="ttname"><a href="group__geometry.html#ac325eeb392c204c197e5dae066088a94">b2SmoothSegment::segment</a></div><div class="ttdeci">b2Segment segment</div><div class="ttdoc">The line segment.</div><div class="ttdef"><b>Definition</b> collision.h:165</div></div>
<div class="ttc" id="agroup__geometry_html_af55c171fd068abfd5dfac18a5fa43d42"><div class="ttname"><a href="group__geometry.html#af55c171fd068abfd5dfac18a5fa43d42">b2SmoothSegment::ghost1</a></div><div class="ttdeci">b2Vec2 ghost1</div><div class="ttdoc">The tail ghost vertex.</div><div class="ttdef"><b>Definition</b> collision.h:162</div></div>
<div class="ttc" id="agroup__geometry_html_structb2_smooth_segment"><div class="ttname"><a href="group__geometry.html#structb2_smooth_segment">b2SmoothSegment</a></div><div class="ttdoc">A smooth line segment with one-sided collision.</div><div class="ttdef"><b>Definition</b> collision.h:160</div></div>
</div><!-- fragment --><p>These ghost vertices must align with vertices of neighboring smooth segments, making them tedious and error-prone to setup.</p>
<p>Smooth segments are not created directly. Instead, you can create chains of smooth segments. See <code><a class="el" href="group__shape.html#structb2_chain_def" title="Used to create a chain of edges.">b2ChainDef</a></code> and <code><a class="el" href="group__shape.html#gad94e527220dbcbfc7c9249fdc23928f8" title="Chain Shape.">b2CreateChain()</a></code>.</p>
<h1><a class="anchor" id="autotoc_md39"></a>
Geometric Queries</h1>
<p>You can perform a geometric queries on a single shape.</p>
<h2><a class="anchor" id="autotoc_md40"></a>
Shape Point Test</h2>
<p>You can test a point for overlap with a shape. You provide a transform for the shape and a world point.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a> point = {5.0f, 2.0f};</div>
<div class="line"><span class="keywordtype">bool</span> hit = <a class="code hl_function" href="group__geometry.html#ga603261cdf86e3b8438bb703adddd59f0">b2PointInCapsule</a>(point, &amp;myCapsule);</div>
<div class="ttc" id="agroup__geometry_html_ga603261cdf86e3b8438bb703adddd59f0"><div class="ttname"><a href="group__geometry.html#ga603261cdf86e3b8438bb703adddd59f0">b2PointInCapsule</a></div><div class="ttdeci">bool b2PointInCapsule(b2Vec2 point, const b2Capsule *shape)</div><div class="ttdoc">Test a point for overlap with a capsule in local space.</div></div>
</div><!-- fragment --><p>See also <code><a class="el" href="group__geometry.html#ga9fd875aaffbf9dc0293ec9e21b9ef46c" title="Test a point for overlap with a circle in local space.">b2PointInCircle()</a></code> and <code><a class="el" href="group__geometry.html#ga81700fac274d6e4ffa081f3b594cf37d" title="Test a point for overlap with a convex polygon in local space.">b2PointInPolygon()</a></code>.</p>
<h2><a class="anchor" id="autotoc_md41"></a>
Ray Cast</h2>
<p>You can cast a ray at a shape to get the point of first intersection and normal vector.</p>
<blockquote class="doxtable">
<p>&zwj;<b>Caution</b>: No hit will register if the ray starts inside a convex shape like a circle or polygon. This is consistent with Box2D treating convex shapes as solid. </p>
</blockquote>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_ray_cast_input">b2RayCastInput</a> input;</div>
<div class="line">input.<a class="code hl_variable" href="group__geometry.html#a2cf529e4ce1598c24912cd3e9fc6eb19">origin</a> = (<a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a>){0.0f, 0.0f};</div>
<div class="line">input.<a class="code hl_variable" href="group__geometry.html#ac134459f70743958da68493438004ece">translation</a> = (<a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a>){1.0f, 0.0f};</div>
<div class="line">input.<a class="code hl_variable" href="group__geometry.html#ae845282b02a2a8cd5c8187f8ca719627">maxFraction</a> = 1.0f;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_cast_output">b2CastOutput</a> output = <a class="code hl_function" href="group__geometry.html#ga34d84739f29d2452cd2c738fb48ed691">b2RayCastPolygon</a>(&amp;input, &amp;myPolygon);</div>
<div class="line"><span class="keywordflow">if</span> (output.<a class="code hl_variable" href="group__geometry.html#a45767f486cf22b7fa774202a904dff45">hit</a> == <span class="keyword">true</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// do something</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__geometry_html_a2cf529e4ce1598c24912cd3e9fc6eb19"><div class="ttname"><a href="group__geometry.html#a2cf529e4ce1598c24912cd3e9fc6eb19">b2RayCastInput::origin</a></div><div class="ttdeci">b2Vec2 origin</div><div class="ttdoc">Start point of the ray cast.</div><div class="ttdef"><b>Definition</b> collision.h:36</div></div>
<div class="ttc" id="agroup__geometry_html_a45767f486cf22b7fa774202a904dff45"><div class="ttname"><a href="group__geometry.html#a45767f486cf22b7fa774202a904dff45">b2CastOutput::hit</a></div><div class="ttdeci">bool hit</div><div class="ttdoc">Did the cast hit?</div><div class="ttdef"><b>Definition</b> collision.h:82</div></div>
<div class="ttc" id="agroup__geometry_html_ac134459f70743958da68493438004ece"><div class="ttname"><a href="group__geometry.html#ac134459f70743958da68493438004ece">b2RayCastInput::translation</a></div><div class="ttdeci">b2Vec2 translation</div><div class="ttdoc">Translation of the ray cast.</div><div class="ttdef"><b>Definition</b> collision.h:39</div></div>
<div class="ttc" id="agroup__geometry_html_ae845282b02a2a8cd5c8187f8ca719627"><div class="ttname"><a href="group__geometry.html#ae845282b02a2a8cd5c8187f8ca719627">b2RayCastInput::maxFraction</a></div><div class="ttdeci">float maxFraction</div><div class="ttdoc">The maximum fraction of the translation to consider, typically 1.</div><div class="ttdef"><b>Definition</b> collision.h:42</div></div>
<div class="ttc" id="agroup__geometry_html_ga34d84739f29d2452cd2c738fb48ed691"><div class="ttname"><a href="group__geometry.html#ga34d84739f29d2452cd2c738fb48ed691">b2RayCastPolygon</a></div><div class="ttdeci">b2CastOutput b2RayCastPolygon(const b2RayCastInput *input, const b2Polygon *shape)</div><div class="ttdoc">Ray cast versus polygon in shape local space. Initial overlap is treated as a miss.</div></div>
<div class="ttc" id="agroup__geometry_html_structb2_cast_output"><div class="ttname"><a href="group__geometry.html#structb2_cast_output">b2CastOutput</a></div><div class="ttdoc">Low level ray-cast or shape-cast output data.</div><div class="ttdef"><b>Definition</b> collision.h:68</div></div>
<div class="ttc" id="agroup__geometry_html_structb2_ray_cast_input"><div class="ttname"><a href="group__geometry.html#structb2_ray_cast_input">b2RayCastInput</a></div><div class="ttdoc">Low level ray-cast input data.</div><div class="ttdef"><b>Definition</b> collision.h:34</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md42"></a>
Shape Cast</h2>
<p>You can also cast a shape at another shape. This uses an abstract way of describing the moving shape. It is represented as a point cloud with a radius. This implies a convex shape even if the input data is not convex. The internal algorithm (GJK) will essentially only use the convex portion.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_shape_cast_input">b2ShapeCastInput</a> input;</div>
<div class="line">input.<a class="code hl_variable" href="group__geometry.html#a46851384fb06ccfed7258cc14f52bf0f">points</a>[0] = (<a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a>){1.0f, 0.0f};</div>
<div class="line">input.<a class="code hl_variable" href="group__geometry.html#a46851384fb06ccfed7258cc14f52bf0f">points</a>[1] = (<a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a>){2.0f, -3.0f};</div>
<div class="line">input.<a class="code hl_variable" href="group__geometry.html#a452dda21cc9ad500ee4e02fc47f053cf">radius</a> = 0.2f;</div>
<div class="line">input.<a class="code hl_variable" href="group__geometry.html#abdc0337032f1377c192e5c018cd3e294">translation</a> = (<a class="code hl_struct" href="group__math.html#structb2_vec2">b2Vec2</a>){1.0f, 0.0f};</div>
<div class="line">input.<a class="code hl_variable" href="group__geometry.html#a4646963b95ddb1ec3dc8b46cfbfad0dc">maxFraction</a> = 1.0f;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="group__geometry.html#structb2_cast_output">b2CastOutput</a> output = <a class="code hl_function" href="group__geometry.html#ga2483a0baaafec5fc17e54434ff6f2efd">b2ShapeCastPolygon</a>(&amp;input, &amp;myPolygon);</div>
<div class="line"><span class="keywordflow">if</span> (output.<a class="code hl_variable" href="group__geometry.html#a45767f486cf22b7fa774202a904dff45">hit</a> == <span class="keyword">true</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// do something</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__geometry_html_a452dda21cc9ad500ee4e02fc47f053cf"><div class="ttname"><a href="group__geometry.html#a452dda21cc9ad500ee4e02fc47f053cf">b2ShapeCastInput::radius</a></div><div class="ttdeci">float radius</div><div class="ttdoc">The radius around the point cloud.</div><div class="ttdef"><b>Definition</b> collision.h:57</div></div>
<div class="ttc" id="agroup__geometry_html_a4646963b95ddb1ec3dc8b46cfbfad0dc"><div class="ttname"><a href="group__geometry.html#a4646963b95ddb1ec3dc8b46cfbfad0dc">b2ShapeCastInput::maxFraction</a></div><div class="ttdeci">float maxFraction</div><div class="ttdoc">The maximum fraction of the translation to consider, typically 1.</div><div class="ttdef"><b>Definition</b> collision.h:63</div></div>
<div class="ttc" id="agroup__geometry_html_a46851384fb06ccfed7258cc14f52bf0f"><div class="ttname"><a href="group__geometry.html#a46851384fb06ccfed7258cc14f52bf0f">b2ShapeCastInput::points</a></div><div class="ttdeci">b2Vec2 points[b2_maxPolygonVertices]</div><div class="ttdoc">A point cloud to cast.</div><div class="ttdef"><b>Definition</b> collision.h:51</div></div>
<div class="ttc" id="agroup__geometry_html_abdc0337032f1377c192e5c018cd3e294"><div class="ttname"><a href="group__geometry.html#abdc0337032f1377c192e5c018cd3e294">b2ShapeCastInput::translation</a></div><div class="ttdeci">b2Vec2 translation</div><div class="ttdoc">The translation of the shape cast.</div><div class="ttdef"><b>Definition</b> collision.h:60</div></div>
<div class="ttc" id="agroup__geometry_html_ga2483a0baaafec5fc17e54434ff6f2efd"><div class="ttname"><a href="group__geometry.html#ga2483a0baaafec5fc17e54434ff6f2efd">b2ShapeCastPolygon</a></div><div class="ttdeci">b2CastOutput b2ShapeCastPolygon(const b2ShapeCastInput *input, const b2Polygon *shape)</div><div class="ttdoc">Shape cast versus a convex polygon. Initial overlap is treated as a miss.</div></div>
<div class="ttc" id="agroup__geometry_html_structb2_shape_cast_input"><div class="ttname"><a href="group__geometry.html#structb2_shape_cast_input">b2ShapeCastInput</a></div><div class="ttdoc">Low level shape cast input in generic form.</div><div class="ttdef"><b>Definition</b> collision.h:49</div></div>
</div><!-- fragment --><p>Even more generic, you can use <code><a class="el" href="group__distance.html#ga71e2e7028b67d243282f232537a811da" title="Perform a linear shape cast of shape B moving and shape A fixed. Determines the hit point,...">b2ShapeCast()</a></code> to linearly cast one point cloud at another point cloud. All shape cast functions use this internally.</p>
<h2><a class="anchor" id="autotoc_md43"></a>
Distance</h2>
<p><code><a class="el" href="group__distance.html#gac4bf4a47f7b62d4656485ba68942838d" title="Compute the closest points between two shapes represented as point clouds.">b2ShapeDistance()</a></code> function can be used to compute the distance between two shapes. The distance function needs both shapes to be converted into a <code><a class="el" href="group__distance.html#structb2_distance_proxy" title="A distance proxy is used by the GJK algorithm. It encapsulates any shape.">b2DistanceProxy</a></code> (which are point clouds with radii). There is also some caching used to warm start the distance function for repeated calls. This can improve performance when the shapes move by small amounts.</p>
<div class="image">
<object type="image/svg+xml" data="distance.svg" style="pointer-events: none;"></object>
<div class="caption">
Distance Function</div></div>
    <h2><a class="anchor" id="autotoc_md44"></a>
Time of Impact</h2>
<p>If two shapes are moving fast, they may <em>tunnel</em> through each other in a single time step.</p>
<div class="image">
<object type="image/svg+xml" data="tunneling2.svg" width="30%" style="pointer-events: none;"></object>
<div class="caption">
Tunneling</div></div>
    <p>The <code><a class="el" href="group__distance.html#ga0d7b925f60608f2fb551c0cd755a4f58" title="Compute the upper bound on time before two shapes penetrate.">b2TimeOfImpact()</a></code> function is used to determine the time when two moving shapes collide. This is called the <em>time of impact</em> (TOI). The main purpose of <code><a class="el" href="group__distance.html#ga0d7b925f60608f2fb551c0cd755a4f58" title="Compute the upper bound on time before two shapes penetrate.">b2TimeOfImpact()</a></code> is for tunnel prevention. Box2D uses this internally to prevent moving objects from tunneling through static shapes.</p>
<p>The <code><a class="el" href="group__distance.html#ga0d7b925f60608f2fb551c0cd755a4f58" title="Compute the upper bound on time before two shapes penetrate.">b2TimeOfImpact()</a></code> identifies an initial separating axis and ensures the shapes do not cross on that axis. This process is repeated as shapes are moved closer together, until they touch or pass by each other.</p>
<p>The TOI function might miss collisions that are clear at the final positions. Nevertheless, it is very fast and adequate for tunnel prevention.</p>
<div class="image">
<object type="image/svg+xml" data="captured_toi.svg" width="30%" style="pointer-events: none;"></object>
<div class="caption">
Captured Collision</div></div>
    <div class="image">
<object type="image/svg+xml" data="missed_toi.svg" width="30%" style="pointer-events: none;"></object>
<div class="caption">
Missed Collision</div></div>
    <p>It is difficult to put a restriction on the rotation magnitude. There may be cases where collisions are missed for small rotations. Normally, these missed rotational collisions should not harm game play. They tend to be glancing collisions.</p>
<p>The function requires two shapes (converted to <code><a class="el" href="group__distance.html#structb2_distance_proxy" title="A distance proxy is used by the GJK algorithm. It encapsulates any shape.">b2DistanceProxy</a></code>) and two <code><a class="el" href="group__distance.html#structb2_sweep" title="This describes the motion of a body/shape for TOI computation.">b2Sweep</a></code> structures. The sweep structure defines the initial and final transforms of the shapes.</p>
<p>You can use fixed rotations to perform a <em>shape cast</em>. In this case, the time of impact function will not miss any collisions.</p>
<h2><a class="anchor" id="autotoc_md45"></a>
Contact Manifolds</h2>
<p>Box2D has functions to compute contact points for overlapping shapes. If we consider circle-circle or circle-polygon, we can only get one contact point and normal. In the case of polygon-polygon we can get two points. These points share the same normal vector so Box2D groups them into a manifold structure. The contact solver takes advantage of this to improve stacking stability.</p>
<div class="image">
<object type="image/svg+xml" data="manifolds.svg" style="pointer-events: none;"></object>
<div class="caption">
Contact Manifold</div></div>
    <p>Normally you don't need to compute contact manifolds directly, however you will likely use the results produced in the simulation.</p>
<p>The <code><a class="el" href="group__collision.html#structb2_manifold" title="A contact manifold describes the contact points between colliding shapes.">b2Manifold</a></code> structure holds a normal vector and up to two contact points. The contact points store the normal and tangential (friction) impulses computed in the rigid body simulation.</p>
<h1><a class="anchor" id="autotoc_md46"></a>
Dynamic Tree</h1>
<p><code><a class="el" href="group__tree.html#structb2_dynamic_tree" title="The dynamic tree structure.">b2DynamicTree</a></code> is used by Box2D to organize large numbers of shapes efficiently. The object does not know directly about shapes. Instead it operates on axis-aligned bounding boxes (<code><a class="el" href="group__math.html#structb2_a_a_b_b" title="Axis-aligned bounding box.">b2AABB</a></code>) with user data integers.</p>
<p>The dynamic tree is a hierarchical AABB tree. Each internal node in the tree has two children. A leaf node is a single user AABB. The tree uses rotations to keep the tree balanced, even in the case of degenerate input.</p>
<p>The tree structure allows for efficient ray casts and region queries. For example, you may have hundreds of shapes in your scene. You could perform a ray cast against the scene in a brute force manner by ray casting each shape. This would be inefficient because it does not take advantage of shapes being spread out. Instead, you can maintain a dynamic tree and perform ray casts against the tree. This traverses the ray through the tree skipping large numbers of shapes.</p>
<p>A region query uses the tree to find all leaf AABBs that overlap a query AABB. This is faster than a brute force approach because many shapes can be skipped.</p>
<div class="image">
<object type="image/svg+xml" data="raycast.svg" width="30%" style="pointer-events: none;"></object>
<div class="caption">
Ray-cast</div></div>
    <div class="image">
<object type="image/svg+xml" data="overlap_test.svg" width="30%" style="pointer-events: none;"></object>
<div class="caption">
Overlap Test</div></div>
    <p>Normally you will not use the dynamic tree directly. Rather you will go through the <code>b2World</code> functions for ray casts and region queries. If you plan to instantiate your own dynamic tree, you can learn how to use it by looking at how Box2D uses it. Also see the <code>DynamicTree</code> sample. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
